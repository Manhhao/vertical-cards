<div id="writing-mode-toggle-container">
    <label class="writing-mode-switch">
        <input type="checkbox" id="writing-mode-toggle" checked>
        <span class="slider round"></span>
        <span class="toggle-label">縦書き</span>
    </label>
</div>

<div class="center-wrapper back">
    <div id="container">
        <div id="dictname">{{DictionaryName}}</div>
        <div id="header-container">
            <div class="header-main-content">
                <div id="expression">{{Word}}</div>
                <div id="reading">{{Reading}}</div>
            </div>
            <div class="audio-buttons">
                <div class="word-audio">{{Audio}}</div>
                <div class="sentence-audio">{{SentenceAudio}}</div>
            </div>
        </div>
        <div id="content-container">
            <div id="glossary-container">
                <div id="definition">{{Glossary}}</div>
                <div id="sentence">{{Sentence}}</div>
            </div>
            <div id="image-container">
                <div id="image">{{Picture}}</div>
            </div>
        </div>
    </div>
</div>

<script>
    // メイン辞書コンテキストオブジェクト
    window.dictionaryContext = {
        // 辞書クラス名マッピング
        dictionaryClassNames: {
            "三省堂 全訳読解古語辞典": "三省堂古語",
            "旺文社 全訳古語辞典": "旺文社古語",
            "角川新字源 改訂新版": "角川新字源",
            "明鏡国語辞典 第三版": "明鏡",
            "大辞泉 第二版": "大辞泉",
            "漢検漢字辞典　第二版": "漢検検定辞典",
            "新明解国語辞典　第八版": "新明解",
            "現代心理学辞典": "心理学辞典",
            "南山堂医学大辞典 第20版": "南山堂医学",
            "三省堂国語辞典　第八版": "三省堂国語"
        },

        // 折りたたみ可能な要素のセレクター
        collapsibleSelectors: {
            "三省堂 全訳読解古語辞典": [
                "div[data-sc絵巻項目]",
                "div[data-sc読解-g]"
            ],
            "旺文社 全訳古語辞典": [
                "div[data-sc用例囲み-g]",
                "div[data-sc発展]"
            ]
        },

        // 表示名マッピング
        displayNameMap: {
            "絵巻項目": "絵巻",
            "発展": "発展事項",
            "読解-g": "読解",
            "用例囲み-g": "例文・訳"
        },

        // 画像要素のセレクター
        imageSelectors: {
            "三省堂 全訳読解古語辞典": "div[data-sc画像-g]",
            "大辞泉 第二版": "div[data-sc-m-image]",
            "現代心理学辞典": "div[data-sc-image]>div:has([data-sc-img])",
            "default": "div[data-sc画像-g], .image-container, .figure, figure, .img-container"
        },

        elements: {},
        activeDictionaries: {},
        isVertical: false,
        initialized: false,
        userPreferences: {
            tategakiEnabled: true
        },

        // ユーザー設定とデバイス幅に基づいて縦書きモードを検出
        detectVerticalMode() {
            const contentContainer = this.elements.contentContainer;
            if (!contentContainer) return false;

            // モバイル表示かどうかチェック（常に横書き）
            const isMobileView = window.innerWidth <= 600;
            this.isVertical = isMobileView ? false : this.userPreferences.tategakiEnabled;

            // 正しいモードのクラスを適用
            contentContainer.classList.toggle('縦書き', this.isVertical);
            contentContainer.classList.toggle('横書き', !this.isVertical);

            return this.isVertical;
        },

        // 文字方向（縦書き/横書き）切替
        toggleWritingMode(enabled) {
            this.userPreferences.tategakiEnabled = typeof enabled === 'boolean' ? enabled : !this.userPreferences.tategakiEnabled;
            localStorage.setItem('tategakiEnabled', this.userPreferences.tategakiEnabled);

            this.detectVerticalMode();

            const toggle = document.getElementById('writing-mode-toggle');
            if (toggle) toggle.checked = this.userPreferences.tategakiEnabled;

            // 正しい状態を適用したので、切替を表示
            this.showWritingModeToggle();

            window.dispatchEvent(new Event('resize'));
        },

        // 高速アクセスのためにDOM要素を保存
        cacheElements() {
            const selectors = {
                dictionaryEntries: { selector: "li[data-dictionary]", all: true },
                definitionContainer: { selector: "#definition" },
                contentContainer: { selector: "#content-container" },
                dictname: { selector: "#dictname" },
                expression: { selector: "#expression" },
                reading: { selector: "#reading" },
                sentence: { selector: "#sentence" },
                imageDiv: { selector: "#image" },
                imageContainer: { selector: "#image-container" },
                centerWrapperBack: { selector: ".center-wrapper.back" }
            };

            for (const [key, { selector, all }] of Object.entries(selectors)) {
                this.elements[key] = all ? document.querySelectorAll(selector) : document.querySelector(selector);
            }
        },

        // 切替ボタンを表示
        showWritingModeToggle() {
            const toggleContainer = document.getElementById('writing-mode-toggle-container');
            if (toggleContainer) {
                // モバイルでない場合のみ表示
                if (window.innerWidth > 600) {
                    toggleContainer.classList.add('ready');
                }
            }
        },

        // DOMからアクティブな辞書を識別
        identifyActiveDictionaries() {
            if (Object.keys(this.activeDictionaries).length > 0) {
                return Object.keys(this.activeDictionaries);
            }

            this.activeDictionaries = {};
            const { dictionaryEntries, dictname } = this.elements;

            if (dictionaryEntries && dictionaryEntries.length > 0) {
                dictionaryEntries.forEach(entry => {
                    const dictName = entry.getAttribute("data-dictionary");
                    if (dictName) this.activeDictionaries[dictName] = true;
                });
            }
            else if (dictname && dictname.textContent.trim()) {
                this.activeDictionaries[dictname.textContent.trim()] = true;
            }

            return Object.keys(this.activeDictionaries);
        },

        /**
         * 辞書固有のCSSクラスを適用し、単一辞書表示の場合は適切なリスト構造を構築します
         * 単一の辞書エントリでもかわいいスタイリングな枠線を一貫して適用するために拡張しました
         */
        applyDictionaryClasses() {
            const { dictionaryClassNames, activeDictionaries, elements } = this;
            const dictionariesToProcess = Object.keys(activeDictionaries);

            if (dictionariesToProcess.length === 0) return;

            const { dictionaryEntries, definitionContainer, dictname } = elements;

            // 単一辞書の場合のリスト構造の確認と構築
            if (definitionContainer && dictionariesToProcess.length === 1) {
                const dictName = dictionariesToProcess[0];

                // 既存のリスト項目がない場合は、リスト構造を作成します
                const existingListItems = definitionContainer.querySelectorAll("li[data-dictionary]");
                if (existingListItems.length === 0 && dictname) {
                    const actualDictName = dictname.textContent.trim();
                    if (!actualDictName) return;

                    // パフォーマンス向上のためにドキュメントフラグメントを使用
                    const fragment = document.createDocumentFragment();

                    // リスト構造を作成
                    const listElement = document.createElement("ol");
                    listElement.className = "dictionary-list";

                    // 単一の辞書用のリストアイテムを作成
                    const listItem = document.createElement("li");
                    listItem.setAttribute("data-dictionary", actualDictName);

                    // 変更前の現在のコンテンツを取得
                    const currentContent = definitionContainer.innerHTML;

                    // 辞書クラスが利用可能な場合は適用
                    if (dictionaryClassNames[actualDictName]) {
                        listItem.classList.add(dictionaryClassNames[actualDictName]);
                    }

                    listItem.innerHTML = currentContent;
                    listElement.appendChild(listItem);
                    fragment.appendChild(listElement);

                    // コンテナクラスを更新
                    definitionContainer.className = "yomitan-glossary";

                    // コンテナをクリアして、フラグメントを挿入
                    definitionContainer.innerHTML = "";
                    definitionContainer.appendChild(fragment);

                    // 要素の保存を更新
                    this.elements.dictionaryEntries = definitionContainer.querySelectorAll("li[data-dictionary]");
                } else if (dictionaryClassNames[dictName]) {
                    // 従来の単一辞書処理: メインコンテナにクラスを追加
                    definitionContainer.classList.add(dictionaryClassNames[dictName]);
                }
            }

            // 個別の辞書エントリを処理（既存の機能を維持）
            if (this.elements.dictionaryEntries && this.elements.dictionaryEntries.length > 0) {
                this.elements.dictionaryEntries.forEach(entry => {
                    const dictName = entry.getAttribute("data-dictionary");
                    if (dictName && dictionaryClassNames[dictName]) {
                        entry.classList.add(dictionaryClassNames[dictName]);
                    }
                });
            }
        },

        // 全てを初期化
        init() {
            if (this.initialized) return;

            // 保存された設定を読み込み
            const savedPreference = localStorage.getItem('tategakiEnabled');
            if (savedPreference !== null) {
                this.userPreferences.tategakiEnabled = savedPreference === 'true';
            }

            this.cacheElements();
            this.identifyActiveDictionaries();
            this.applyDictionaryClasses();
            this.detectVerticalMode();

            const toggle = document.getElementById('writing-mode-toggle');
            if (toggle) toggle.checked = this.userPreferences.tategakiEnabled;

            // すべての設定が完了してから切替を表示
            setTimeout(() => this.showWritingModeToggle(), 50);

            this.initialized = true;
        }
    };

    // 辞書カードを初期化
    function initializeDictionaryCard() {
        if (!window.dictionaryContext) return;

        window.dictionaryContext.init();

        const ctx = window.dictionaryContext;

        // どの要素が存在するかチェック
        const elementsExist = {};
        for (const key in ctx.elements) {
            elementsExist[key] = ctx.elements[key] !== null &&
                !(ctx.elements[key] instanceof NodeList && ctx.elements[key].length === 0);
        }

        // バッチ操作を作成
        requestAnimationFrame(() => {
            // 条件を満たす全ての機能関数を実行
            if (elementsExist.sentence) handleEmptySentence();
            if (elementsExist.expression && elementsExist.reading && elementsExist.sentence) handleDuplicateContent();
            if (elementsExist.definitionContainer) setupCyclableDefinitions();
            setupCollapsibleElements();
            handleImages();
            if (elementsExist.imageContainer && elementsExist.imageDiv) hideEmptyImageContainer();
            setupWritingModeToggle();

            // 全ての操作が完了した後にイベントリスナーを設定
            setupGlobalEventListeners();
        });
    }

    // 縦書き切替の設定
    function setupWritingModeToggle() {
        const toggle = document.getElementById('writing-mode-toggle');
        if (!toggle) return;

        // 辞書コンテキストに基づいて初期状態を設定
        toggle.checked = window.dictionaryContext.userPreferences.tategakiEnabled;

        // 変更イベントリスナーを追加
        toggle.addEventListener('change', function () {
            window.dictionaryContext.toggleWritingMode(this.checked);
        });

        // モバイルでは切替を非表示
        if (window.innerWidth <= 600) {
            toggle.parentElement.parentElement.style.display = 'none';
        }
    }

    // 空の画像コンテナを非表示
    function hideEmptyImageContainer() {
        const { imageDiv, imageContainer } = window.dictionaryContext.elements;
        if (!imageContainer || !imageDiv) return;

        const hasImages = imageDiv.getElementsByTagName('img').length > 0;
        const hasText = imageDiv.innerText.trim() !== '';

        if (!hasImages && !hasText) {
            imageContainer.style.display = 'none';
        }
    }

    // 空の例文フィールドを非表示
    function handleEmptySentence() {
        const sentenceDiv = window.dictionaryContext.elements.sentence;
        if (sentenceDiv && sentenceDiv.textContent.trim() === "") {
            sentenceDiv.style.display = "none";
        }
    }

    // 重複コンテンツを非表示
    function handleDuplicateContent() {
        const { expression, reading, sentence } = window.dictionaryContext.elements;
        if (!expression) return;

        const expressionText = expression.textContent.trim();
        const readingText = reading ? reading.textContent.trim() : null;
        const sentenceText = sentence ? sentence.textContent.trim() : null;

        if (reading && expressionText === readingText) {
            reading.style.display = "none";
        }

        if (sentence && expressionText === sentenceText) {
            sentence.style.display = "none";
        }
    }

    // 辞書の定義を切り替えられるようにするための便利な機能です。
    function setupCyclableDefinitions() {
        const definitionContainer = window.dictionaryContext.elements.definitionContainer;
        if (!definitionContainer) return;

        const definitionItems = Array.from(definitionContainer.querySelectorAll("li[data-dictionary]"));
        if (definitionItems.length <= 1) return; // 定義が一つだけならサイクルする必要ない

        console.log(definitionItems)
        // 最初は全ての定義を非表示にしておきます
        definitionItems.forEach(item => item.style.display = "none");

        // デフォルトでは最初の定義だけ表示する
        if (definitionItems[0]) {
            definitionItems[0].style.display = "";
        }

         // パフォーマンスを良くするために、全ての要素を一度にドキュメントフラグメントで作成します
        const fragment = document.createDocumentFragment();
        const counterElement = document.createElement("div");
        const leftEdge = document.createElement("div");
        const rightEdge = document.createElement("div");

        counterElement.className = "definition-counter";
        leftEdge.className = "definition-left-edge";
        rightEdge.className = "definition-right-edge";

        fragment.appendChild(counterElement);
        fragment.appendChild(leftEdge);
        fragment.appendChild(rightEdge);

        const containerToUse = window.dictionaryContext.elements.contentContainer || definitionContainer;
        containerToUse.style.position = "relative";

        let currentStartIndex = 0;
        let visibleCount = 1;
        const totalDefinitions = definitionItems.length;

        // 表示用の辞書名を取得します
        const dictionaryNames = definitionItems.map(item => {
            const dictName = item.getAttribute("data-dictionary");
            return dictName || `Dictionary ${definitionItems.indexOf(item) + 1}`;
        });

        let lastMeasuredWidth = 0;
        let lastMeasuredHeight = 0;
        let hasCalculatedInitialLayout = false;

        // 表示できる定義の数を計算します
        function calculateVisibleCount() {
            // 縦モードかどうかを再チェックします
            window.dictionaryContext.detectVerticalMode();
            const isVertical = window.dictionaryContext.isVertical;

            // 横モードの場合は特別な処理が必要です
            if (!isVertical) {
                // 横モードでは、他のコンテンツの後に利用可能なスペースを考慮する必要があります
                const sentenceEl = document.getElementById('sentence');
                const contentRect = containerToUse.getBoundingClientRect();
                const viewportHeight = window.innerHeight;

                // 利用可能な高さを計算します
                const contentTop = containerToUse.getBoundingClientRect().top;
                const otherContentHeight = sentenceEl ?
                    sentenceEl.getBoundingClientRect().bottom - contentTop :
                    100; // 見つからない場合のデフォルトのパディング

                // 最大使用可能高さを計算します（ビューポート） - （ヘッダー） - （パディング）
                const maxHeight = viewportHeight * 0.65; // ビューポートの65%を最大値として使用
                const availableHeight = Math.max(50, maxHeight - otherContentHeight);

                // 少なくとも一つの定義が表示されるように最小の高さを設定します
                containerToUse.style.minHeight = otherContentHeight + 150 + 'px';

                // 測定のためにアイテムを一時的に表示しますが、非表示にしておきます
                definitionItems.forEach(item => {
                    item.style.display = "";
                    item.style.visibility = "hidden";
                });

                // レイアウト計算を強制します
                containerToUse.offsetHeight;

                // 少なくとも一つの定義を常に表示し、
                // 完全に収まる場合のみ追加します
                let count = 0;
                let firstItemHeight = 0;

                // まず、バッファー付きの最初のアイテムの高さを測定します
                if (definitionItems[0]) {
                    const firstItemRect = definitionItems[0].getBoundingClientRect();
                    const firstItemStyle = window.getComputedStyle(definitionItems[0]);

                    firstItemHeight = firstItemRect.height +
                        parseFloat(firstItemStyle.marginTop) +
                        parseFloat(firstItemStyle.marginBottom);

                    // 安全バッファーを追加します（10%）
                    firstItemHeight = firstItemHeight * 1.1;

                    // 常に最初の定義を表示します
                    count = 1;
                }

                // もっと定義を表示するスペースがあれば、追加の定義を慎重に測定します
                if (firstItemHeight < availableHeight * 0.7) { // 最初の定義には最大70%を使用
                    let remainingSpace = availableHeight - firstItemHeight;

                    // 完全に収まる場合は追加の定義を追加してみます
                    for (let i = 1; i < definitionItems.length; i++) {
                        const item = definitionItems[i];
                        const itemRect = item.getBoundingClientRect();
                        const itemStyle = window.getComputedStyle(item);

                        const itemHeight = itemRect.height +
                            parseFloat(itemStyle.marginTop) +
                            parseFloat(itemStyle.marginBottom);

                        // 安全のために10%のバッファーを追加します
                        const itemWithBuffer = itemHeight * 1.1;

                        // 余裕を持って完全に収まる場合のみ追加します
                        if (remainingSpace >= itemWithBuffer) {
                            remainingSpace -= itemWithBuffer;
                            count++;
                        } else {
                            // これ以上収まらない場合は停止します
                            break;
                        }
                    }
                }

                // 可視性をリセットします
                definitionItems.forEach(item => {
                    item.style.visibility = "";
                    item.style.display = "none";
                });

                // 少なくとも一つ、最大でも全ての定義を表示します
                return Math.max(1, Math.min(count, totalDefinitions));
            }

            // 縦モードの計算はリクエスト通り変更しません
            const containerRect = containerToUse.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;

            // 寸法が変わっていなければ再計算をスキップします
            if (containerWidth === lastMeasuredWidth &&
                containerHeight === lastMeasuredHeight &&
                hasCalculatedInitialLayout) {
                return visibleCount;
            }

            lastMeasuredWidth = containerWidth;
            lastMeasuredHeight = containerHeight;

            // 測定のためにアイテムを一時的に表示しますが、非表示にしておきます
            definitionItems.forEach(item => {
                item.style.display = "";
                item.style.visibility = "hidden";
            });

            const containerSize = containerWidth; // 縦モードの場合
            const safetyMargin = 0.9;
            const usableSpace = containerSize * safetyMargin;

            let totalUsedSpace = 0;
            let count = 0;

            // 縦モードの計算
            for (const item of definitionItems) {
                const itemRect = item.getBoundingClientRect();
                const style = window.getComputedStyle(item);

                const itemSize = itemRect.width +
                    parseFloat(style.marginLeft) +
                    parseFloat(style.marginRight);

                if (totalUsedSpace + itemSize > usableSpace) break;

                totalUsedSpace += itemSize;
                count++;
            }

            // 可視性をリセットします
            definitionItems.forEach(item => {
                item.style.visibility = "";
                item.style.display = "none";
            });

            hasCalculatedInitialLayout = true;
            return Math.max(1, count);
        }

        // 表示する定義を更新します
        function updateVisibleDefinitions() {
            // まず全て非表示にします
            definitionItems.forEach(item => item.style.display = "none");

            const actualVisibleCount = Math.min(visibleCount, totalDefinitions - currentStartIndex);
            for (let i = 0; i < actualVisibleCount; i++) {
                definitionItems[currentStartIndex + i].style.display = "";
            }

            const endIndex = currentStartIndex + actualVisibleCount - 1;

            if (visibleCount >= totalDefinitions) {
                counterElement.textContent = "全てを表示";
            } else if (actualVisibleCount === 1) {
                counterElement.textContent = `(${currentStartIndex + 1}/${totalDefinitions})`;
            } else {
                counterElement.textContent = `(${currentStartIndex + 1}-${endIndex + 1}/${totalDefinitions})`;
            }

            // ナビゲーション要素の表示/非表示を切り替えます
            const showNavigation = visibleCount < totalDefinitions;
            leftEdge.style.display = rightEdge.style.display = showNavigation ? "" : "none";
        }

        // 次/前の定義セットにサイクルします
        function cycleDefinitions(direction) {
            if (visibleCount >= totalDefinitions) return;

            const totalGroups = Math.ceil(totalDefinitions / visibleCount);
            const currentGroupIndex = Math.floor(currentStartIndex / visibleCount);

            if (direction === "next") {
                const nextGroupIndex = (currentGroupIndex + 1) % totalGroups;
                currentStartIndex = nextGroupIndex * visibleCount;
            } else {
                const prevGroupIndex = (currentGroupIndex - 1 + totalGroups) % totalGroups;
                currentStartIndex = prevGroupIndex * visibleCount;
            }

            updateVisibleDefinitions();
        }

        // ナビゲーションのイベントリスナー
        leftEdge.addEventListener("click", () => cycleDefinitions("prev"));
        rightEdge.addEventListener("click", () => cycleDefinitions("next"));

        // キーボードナビゲーション
        document.addEventListener("keydown", (event) => {
            if (event.key === "ArrowLeft" || event.keyCode === 37) {
                cycleDefinitions("prev");
            } else if (event.key === "ArrowRight" || event.keyCode === 39) {
                cycleDefinitions("next");
            }
        }, { passive: true });

        function debounce(func, wait) {
            let timeout;
            return function () {
                clearTimeout(timeout);
                timeout = setTimeout(func, wait);
            };
        }

        // 要素を初期化します
        containerToUse.appendChild(fragment);
        counterElement.textContent = `(1/${totalDefinitions})`;

        // 必要に応じてナビゲーションを表示します
        leftEdge.style.display = rightEdge.style.display = totalDefinitions > 1 ? "" : "none";

        // 初期計算をスケジュールします
        const scheduleInitialCalculation = window.requestIdleCallback || requestAnimationFrame;
        scheduleInitialCalculation(() => {
            visibleCount = calculateVisibleCount();
            updateVisibleDefinitions();
        });

        // デバウンスでリサイズを処理します
        const debouncedResize = debounce(() => {
            visibleCount = calculateVisibleCount();
            updateVisibleDefinitions();
        }, 250);

        window.addEventListener('resize', debouncedResize, { passive: true });

        // 書き込みモードの変更を処理します
        const originalDetectVerticalMode = window.dictionaryContext.detectVerticalMode;
        window.dictionaryContext.detectVerticalMode = function () {
            const wasVertical = this.isVertical;
            const result = originalDetectVerticalMode.call(this);

            if (wasVertical !== this.isVertical) {
                // 保存された寸法をリセットします
                lastMeasuredWidth = lastMeasuredHeight = 0;

                // レイアウトが落ち着くまで少し遅延させて次のフレームで再計算します
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        visibleCount = calculateVisibleCount();
                        updateVisibleDefinitions();

                        // 横モードの場合、コンテンツに基づいてコンテナの高さを調整します
                        if (!this.isVertical) {
                            const visibleItems = definitionItems.filter(item => item.style.display === "");
                            if (visibleItems.length > 0) {
                                // 最後の表示アイテムの下部を見つけます
                                const lastItemRect = visibleItems[visibleItems.length - 1].getBoundingClientRect();
                                const containerRect = containerToUse.getBoundingClientRect();
                                const requiredHeight = lastItemRect.bottom - containerRect.top + 30; // パッディングを追加

                                // 表示されている全ての定義に対応するために最小の高さを設定します
                                const minHeight = visibleItems.length === 1 ? requiredHeight : Math.max(300, requiredHeight);
                                containerToUse.closest('#content-container').style.minHeight = `${minHeight}px`;
                            }
                        }
                    });
                }, 50); // レイアウトが落ち着くまでの小さな遅延
            }

            return result;
        };
    }

    // 折りたたみ要素の設定
    function setupCollapsibleElements() {
        const { collapsibleSelectors, displayNameMap, activeDictionaries } = window.dictionaryContext;
        const dictionariesToProcess = Object.keys(activeDictionaries);

        // 要素を処理する前に、すぐにイベントハンドラーを登録
        // これにより、ハンドラーができるだけ早く有効になる
        if (!window.dictionaryContext.collapsibleHandlerRegistered) {
            window.dictionaryContext.collapsibleHandlerRegistered = true;

            // ポインターイベントを使用（タッチとマウス用）
            document.addEventListener('pointerdown', function (e) {
                if (e.target && (
                    e.target.hasAttribute('data-clickable') ||
                    e.target.classList.contains('collapsible-header')
                )) {
                    const wrapper = e.target.closest('.collapsible-wrapper');
                    if (wrapper) {
                        wrapper.classList.toggle('collapsed');
                    }
                }
            }, { passive: true });

            // 非常に早いクリック用のバックアップとしてmousedownを使用
            document.addEventListener('mousedown', function (e) {
                if (e.target && e.target.classList.contains('collapsible-header')) {
                    const wrapper = e.target.closest('.collapsible-wrapper');
                    if (wrapper) {
                        wrapper.classList.toggle('collapsed');
                    }
                }
            }, { passive: true, capture: true });
        }

        if (dictionariesToProcess.length === 0) return;

        const allContentElements = [];

        // 折りたたみ可能にする必要のある要素を特定
        dictionariesToProcess.forEach(dictionaryName => {
            const currentSelectors = collapsibleSelectors[dictionaryName];
            if (!currentSelectors) return;

            const entries = document.querySelectorAll(`li[data-dictionary="${dictionaryName}"]`);
            const container = entries.length > 0 ? entries : [document];

            container.forEach(ctx => {
                currentSelectors.forEach(selector => {
                    const elements = ctx.querySelectorAll(selector);
                    if (!elements.length) return;

                    const attrMatch = selector.match(/data-sc([^=\]]*)/);
                    const rawAttrName = attrMatch ? attrMatch[1] : selector.split('[')[1]?.split(']')[0];
                    if (!rawAttrName) return;

                    const displayName = displayNameMap[rawAttrName] || rawAttrName;

                    elements.forEach(el => {
                        // 既にラップされている場合はスキップ
                        if (el.parentNode && el.parentNode.classList?.contains('collapsible-content')) return;

                        allContentElements.push({
                            element: el,
                            parent: el.parentNode,
                            displayName: displayName
                        });
                    });
                });
            });
        });

        // 処理するものがない場合はスキップ
        if (allContentElements.length === 0) return;

        // ドキュメントフラグメントを作成
        const fragment = document.createDocumentFragment();
        const wrappers = [];

        // 全ての要素のラッパーを作成
        allContentElements.forEach(item => {
            const { element, parent, displayName } = item;

            const wrapper = document.createElement('div');
            wrapper.className = 'collapsible-wrapper collapsed';

            const header = document.createElement('div');
            header.className = 'collapsible-header';
            header.textContent = displayName;

            // クリック可能としてデータ属性でマーク
            header.setAttribute('data-clickable', 'true');

            // 即時応答用の直接ハンドラーを追加
            header.addEventListener('mousedown', function (e) {
                wrapper.classList.toggle('collapsed');
                e.stopPropagation();
            }, { capture: true });

            const content = document.createElement('div');
            content.className = 'collapsible-content';

            // ラッパーに追加
            wrapper.appendChild(header);
            wrapper.appendChild(content);

            // バッチ挿入用に保存
            wrappers.push({
                wrapper,
                content,
                element,
                parent
            });
        });

        wrappers.forEach(({ wrapper, content, element, parent }) => {
            // 要素を現在の親から削除
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }

            // 要素をコンテンツラッパーに追加
            content.appendChild(element);

            // ラッパーを元の位置の前に挿入
            parent.appendChild(wrapper);
        });

        // 既存のすべてのヘッダーをクリック可能としてマークし、直接ハンドラーを追加
        document.querySelectorAll('.collapsible-header:not([data-clickable])').forEach(header => {
            header.setAttribute('data-clickable', 'true');

            // 即時クリック用の直接ハンドラーを追加
            const wrapper = header.closest('.collapsible-wrapper');
            if (wrapper) {
                header.addEventListener('mousedown', function (e) {
                    wrapper.classList.toggle('collapsed');
                    e.stopPropagation();
                }, { capture: true });
            }
        });
    }

    // 画像の処理
    function handleImages() {
        const { imageSelectors, activeDictionaries } = window.dictionaryContext;
        const dictionaries = Object.keys(activeDictionaries);

        if (dictionaries.length === 0) return;

        // 非表示にする必要のあるすべての画像を収集
        const imagesToHide = [];

        function collectExtraImages(container, selector) {
            const images = container.querySelectorAll(selector);
            if (images.length > 1) {
                for (let i = 1; i < images.length; i++) {
                    imagesToHide.push(images[i]);
                }
            }
        }

        // <li>辞書エントリを処理
        for (const dictName of dictionaries) {
            const selector = imageSelectors[dictName] || imageSelectors["default"];
            document.querySelectorAll(`li[data-dictionary="${dictName}"]`)
                .forEach(entry => collectExtraImages(entry, selector));
        }

        // 単一辞書エントリのレイアウトを処理
        const dictnameEl = window.dictionaryContext.elements.dictname;
        if (dictnameEl) {
            const singleDict = dictnameEl.textContent.trim();
            if (activeDictionaries[singleDict]) {
                const selector = imageSelectors[singleDict] || imageSelectors["default"];
                collectExtraImages(document, selector);
            }
        }

        // 変更を一度に適用
        if (imagesToHide.length > 0) {
            imagesToHide.forEach(img => {
                img.style.display = "none";
            });
        }
    }

    // グローバルイベントリスナーの設定
    function setupGlobalEventListeners() {
        let resizeRAF = null;
        window.addEventListener('resize', function () {
            if (resizeRAF) {
                cancelAnimationFrame(resizeRAF);
            }

            resizeRAF = requestAnimationFrame(function () {
                // リサイズ時に切替の表示／非表示を処理
                const toggle = document.getElementById('writing-mode-toggle');
                if (toggle) {
                    const toggleContainer = toggle.parentElement.parentElement;
                    toggleContainer.style.display = window.innerWidth <= 600 ? 'none' : '';
                }

                window.dictionaryContext.detectVerticalMode();
            });
        }, { passive: true });

        // 折りたたみヘッダー用のイベントハンドラー
        if (!window.dictionaryContext.collapsibleHandlerRegistered) {
            window.dictionaryContext.collapsibleHandlerRegistered = true;

            // ポインターイベントを使用
            document.addEventListener('pointerdown', function (e) {
                if (e.target && (
                    e.target.hasAttribute('data-clickable') ||
                    e.target.classList.contains('collapsible-header')
                )) {
                    const wrapper = e.target.closest('.collapsible-wrapper');
                    if (wrapper) {
                        wrapper.classList.toggle('collapsed');
                    }
                }
            }, { passive: true });
        }

        // 必要に応じて既存のヘッダーをクリック可能としてマーク
        document.querySelectorAll('.collapsible-header:not([data-clickable])').forEach(header => {
            header.setAttribute('data-clickable', 'true');
        });
    }

    // 読み込みによる辞書コンテンツの待機
    function waitForDictionaryContent() {
        const criticalElements = ['definition', 'content-container', 'dictname'];

        // 重要な要素が準備できているかチェック
        function checkReadiness() {
            return criticalElements.every(id => document.getElementById(id));
        }

        // すべての準備ができていれば初期化
        if (checkReadiness()) {
            initializeDictionaryCard();
            return;
        }

        // MutationObserverを使用
        const observer = new MutationObserver(() => {
            if (checkReadiness()) {
                observer.disconnect();
                initializeDictionaryCard();
            }
        });

        // 追加されたノード用にbodyのみを監視
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // RAFによるフォールバックタイムアウト
        let frameCount = 0;
        function checkAfterFrames() {
            if (checkReadiness() || frameCount > 60) {
                observer.disconnect();
                initializeDictionaryCard();
            } else {
                frameCount++;
                requestAnimationFrame(checkAfterFrames);
            }
        }

        requestAnimationFrame(checkAfterFrames);
    }

    // 適切なタイミングで初期化を開始
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', waitForDictionaryContent);
    } else {
        waitForDictionaryContent();
    }
</script>
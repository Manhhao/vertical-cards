<div class="center-wrapper back">
    <div id="container">
        <div id="dictname" style="position: relative; right: 0; top: 0; margin-bottom: 0.5em;">{{DictionaryName}}</div>

        <div id="header-container">
            <div class="audio-buttons">
                <div class="word-audio">{{Audio}}</div>
                <div class="sentence-audio">{{SentenceAudio}}</div>
            </div>
            <div class="header-main-content">
                <div id="expression">{{Word}}</div>
                <div id="reading">{{Reading}}</div>
            </div>
        </div>

        <div id="content-container">
            <div id="glossary-container">
                <div id="definition">{{Glossary}}</div>
                <div id="sentence">{{Sentence}}</div>
            </div>

            <div id="image-container">
                <div id="image">{{Picture}}</div>
            </div>
        </div>
    </div>
</div>

<script>
    // Main dictionary context object
    window.dictionaryContext = {
        cssFiles: {
            "三省堂 全訳読解古語辞典": "_skogo_anki.css",
            "旺文社 全訳古語辞典": "_ozk5_anki.css",
            "角川新字源 改訂新版": "_shinjigen_anki.css",
            "明鏡国語辞典 第三版": "_meikyo_anki.css"
        },

        collapsibleSelectors: {
            "三省堂 全訳読解古語辞典": [
                "div[data-sc絵巻項目]",
                "div[data-sc読解-g]"
            ],
            "旺文社 全訳古語辞典": [
                "div[data-sc用例囲み-g]",
                "div[data-sc発展]"
            ]
        },

        displayNameMap: {
            // 三省堂 全訳読解古語辞典
            "絵巻項目": "絵巻",
            "発展": "発展事項",
            "読解-g": "読解",

            // 旺文社 全訳古語辞典
            "用例囲み-g": "例文・訳"
        },

        imageSelectors: {
            "三省堂 全訳読解古語辞典": "div[data-sc画像-g]",
            "大辞泉 第二版": "div[data-sc-m-image]",

            // Default selectors
            "default": "div[data-sc画像-g], .image-container, .figure, figure, .img-container"
        },

        // DOM element caches
        elements: {
            dictionaryEntries: null,
            collapsibleContents: null,
            definitionContainer: null,
            contentContainer: null,
            dictname: null,
            expression: null,
            reading: null,
            sentence: null
        },

        activeDictionaries: {},
        isVertical: false,

        detectVerticalMode() {
            this.isVertical = window.getComputedStyle(document.body).writingMode === 'vertical-rl';
            document.body.classList.toggle('vertical-mode', this.isVertical);

            // Apply to content container
            if (this.elements.contentContainer) {
                this.elements.contentContainer.classList.toggle('vertical-mode', this.isVertical);
            }

            return this.isVertical;
        },

        cacheElements() {
            // Cache common elements
            this.elements.dictionaryEntries = document.querySelectorAll("li[data-dictionary]");
            this.elements.collapsibleContents = document.querySelectorAll('.collapsible-content');
            this.elements.definitionContainer = document.getElementById("definition");
            this.elements.contentContainer = document.getElementById("content-container");
            this.elements.dictname = document.getElementById("dictname");
            this.elements.expression = document.getElementById("expression");
            this.elements.reading = document.getElementById("reading");
            this.elements.sentence = document.getElementById("sentence");
            this.elements.centerWrapperBack = document.querySelector('.center-wrapper.back')
        },

        identifyActiveDictionaries() {
            // Reset the active dictionaries
            this.activeDictionaries = {};

            // Find dictionaries from list items
            if (this.elements.dictionaryEntries.length > 0) {
                this.elements.dictionaryEntries.forEach((entry) => {
                    const dictName = entry.getAttribute("data-dictionary");
                    if (dictName) {
                        this.activeDictionaries[dictName] = true;
                    }
                });
            }
            // If no dictionaries found in list items, check the DictionaryName field
            else if (this.elements.dictname && this.elements.dictname.textContent.trim()) {
                const dictionaryName = this.elements.dictname.textContent.trim();
                this.activeDictionaries[dictionaryName] = true;
            }

            console.log("Active dictionaries:", Object.keys(this.activeDictionaries));
            return Object.keys(this.activeDictionaries);
        },

        init() {
            this.cacheElements();
            this.detectVerticalMode();
            this.identifyActiveDictionaries();
        }
    };

    // Main initialization function
    function initializeDictionaryCard() {
        window.dictionaryContext.init();

        // Run all features using cached elements
        handleEmptySentence();
        handleDuplicateContent();
        loadDictionaryCssFiles();
        setupCyclableDefinitions();
        setupCollapsibleElements();
        handleImages();
        hideEmptyImageContainer();
        setupAdaptiveMargin();

        // Set up event listeners
        setupGlobalEventListeners();
    }

    // Feature: Hide image container if it's empty
    function hideEmptyImageContainer() {
        const imageDiv = document.getElementById('image');
        const imageContainer = document.getElementById('image-container');

        if (!imageContainer) return;

        // Check if the image div is empty or only contains whitespace
        const isEmpty = !imageDiv ||
            (imageDiv.getElementsByTagName('img').length === 0 &&
                imageDiv.innerText.trim() === '');

        // Hide the container if empty
        if (isEmpty) {
            imageContainer.style.display = 'none';
        }
    }

    // Feature: Hide sentence field if empty
    function handleEmptySentence() {
        const sentenceDiv = window.dictionaryContext.elements.sentence;
        if (sentenceDiv && sentenceDiv.textContent.trim() === "") {
            sentenceDiv.style.display = "none";
        }
    }

    // Feature: Hide reading and sentence if same as term
    function handleDuplicateContent() {
        const expressionDiv = window.dictionaryContext.elements.expression;
        const readingDiv = window.dictionaryContext.elements.reading;
        const sentenceDiv = window.dictionaryContext.elements.sentence;

        if (expressionDiv && readingDiv &&
            expressionDiv.textContent.trim() === readingDiv.textContent.trim()) {
            readingDiv.style.display = "none";
        }

        if (expressionDiv && sentenceDiv &&
            expressionDiv.textContent.trim() === sentenceDiv.textContent.trim()) {
            sentenceDiv.style.display = "none";
        }
    }

    // Feature: Load dictionary CSS files for dictionaries
    function loadDictionaryCssFiles() {
        const { cssFiles, activeDictionaries } = window.dictionaryContext;

        // Load CSS for active dictionaries
        Object.keys(activeDictionaries).forEach(dictionaryName => {
            if (cssFiles[dictionaryName]) {
                const link = document.createElement("link");
                link.rel = "stylesheet";
                link.href = cssFiles[dictionaryName];
                document.head.appendChild(link);
                console.log(`Loaded CSS for dictionary: ${dictionaryName}`);
            }
        });
    }

    // Feature: Cyclable definitions
    function setupCyclableDefinitions() {
        const definitionContainer = window.dictionaryContext.elements.definitionContainer;
        if (!definitionContainer) return;

        const definitionItems = definitionContainer.querySelectorAll("li");

        // If there are multiple definitions
        if (definitionItems.length > 1) {
            const counterElement = document.createElement("div");
            counterElement.className = "definition-counter";

            // Add left and right edges for clicking
            const leftEdge = document.createElement("div");
            const rightEdge = document.createElement("div");

            leftEdge.className = "definition-left-edge";
            rightEdge.className = "definition-right-edge";

            const containerToUse = window.dictionaryContext.elements.contentContainer || definitionContainer;
            containerToUse.style.position = "relative";
            containerToUse.appendChild(counterElement);
            containerToUse.appendChild(leftEdge);
            containerToUse.appendChild(rightEdge);

            // Apply orientation-specific styling
            adjustCyclablePositions();

            let currentIndex = 0;

            // Hide all definitions except the first one
            for (let i = 1; i < definitionItems.length; i++) {
                definitionItems[i].style.display = "none";
            }

            // Update counter display
            function updateCounter() {
                counterElement.textContent = `${currentIndex + 1}/${definitionItems.length}`;
            }
            updateCounter();

            // Function to cycle to the next definition
            function cycleDefinition(direction) {
                definitionItems[currentIndex].style.display = "none";

                // Calculate new index
                if (direction === "next") {
                    currentIndex = (currentIndex + 1) % definitionItems.length;
                } else {
                    currentIndex = (currentIndex - 1 + definitionItems.length) % definitionItems.length;
                }

                definitionItems[currentIndex].style.display = "";
                updateCounter();
            }

            // Add click events to the edges
            leftEdge.addEventListener("click", () => cycleDefinition("prev"));
            rightEdge.addEventListener("click", () => cycleDefinition("next"));

            // Function to handle arrow key navigation
            function handleArrowKeys(event) {
                if (event.key === "ArrowLeft" || event.keyCode === 37) {
                    cycleDefinition("prev");
                } else if (event.key === "ArrowRight" || event.keyCode === 39) {
                    cycleDefinition("next");
                }
            }

            document.addEventListener("keydown", handleArrowKeys);
        }
    }

    // Helper function for cyclable definitions
    function adjustCyclablePositions() {
        const isVertical = window.dictionaryContext.isVertical;
        const containerToUse = window.dictionaryContext.elements.contentContainer ||
            window.dictionaryContext.elements.definitionContainer;

        if (containerToUse) {
            containerToUse.classList.toggle("vertical-mode", isVertical);
        }
    }

    // Feature: Adaptive margin for vertical layout
    function setupAdaptiveMargin() {
        if (!window.dictionaryContext.isVertical) return;

        // ===== CUSTOMIZABLE SETTINGS =====
        const NARROW_CONTENT_MAX = 300;  // Content narrower than this is considered "narrow"
        const MEDIUM_CONTENT_MAX = 600;  // Content between NARROW_MAX and this is "medium"

        const NARROW_CONTENT_CLAMP = {
            min: 16,   // Minimum margin in vw
            max: 30,   // Maximum margin in vw
            base: 16,  // Base value before viewport adjustment
            factor: 0.01  // How much to adjust per pixel of viewport width (from REFERENCE_VIEWPORT_WIDTH)
        };

        // Clamp values for medium content
        const MEDIUM_CONTENT_CLAMP = {
            min: 10,
            max: 25,
            base: 10,
            factor: 0.01
        };

        // Clamp values for wide content
        const WIDE_CONTENT_CLAMP = {
            min: 4,
            max: 15,
            base: 4,
            factor: 0.007
        };

        // Viewport width reference point
        const REFERENCE_VIEWPORT_WIDTH = 601;

        // Retina display adjustment
        const RETINA_ADJUSTMENT = 2;

        function calculateMargin() {
            const contentContainer = window.dictionaryContext.elements.contentContainer;
            const wrapper = window.dictionaryContext.elements.centerWrapperBack;

            // If either element doesn't exist, exit
            if (!contentContainer || !wrapper) return;

            const contentWidth = contentContainer.scrollWidth || contentContainer.offsetWidth;
            const viewportWidth = window.innerWidth;

            let clampValues;

            if (contentWidth < NARROW_CONTENT_MAX) {
                clampValues = NARROW_CONTENT_CLAMP;
                console.log("Using narrow content clamp values");
            }
            else if (contentWidth < MEDIUM_CONTENT_MAX) {
                clampValues = MEDIUM_CONTENT_CLAMP;
                console.log("Using medium content clamp values");
            }
            else {
                clampValues = WIDE_CONTENT_CLAMP;
                console.log("Using wide content clamp values");
            }

            // Calculate the preferred value based on viewport width
            const viewportAdjustment = (viewportWidth - REFERENCE_VIEWPORT_WIDTH) * clampValues.factor;
            const preferredMargin = clampValues.base + viewportAdjustment;

            const clampedMargin = Math.max(clampValues.min, Math.min(preferredMargin, clampValues.max));
            wrapper.style.marginRight = clampedMargin + 'vw';

            // Apply Retina adjustment if needed
            if (window.devicePixelRatio >= 2) {
                const retinaMargin = Math.max(clampValues.min, clampedMargin - RETINA_ADJUSTMENT);
                wrapper.style.marginRight = retinaMargin + 'vw';
                console.log(`Retina display detected, adjusted margin: ${retinaMargin}vw`);
            }
        }

        calculateMargin();
        window.addEventListener('resize', calculateMargin);

        const observer = new MutationObserver(calculateMargin);

        // Observe the content container for changes
        const contentContainer = window.dictionaryContext.elements.contentContainer;
        if (contentContainer) {
            observer.observe(contentContainer, {
                childList: true,
                subtree: true,
                characterData: true,
                attributes: true
            });
        }

        return observer;
    }

    // Feature: Collapsible elements
    function setupCollapsibleElements() {
        const { collapsibleSelectors, displayNameMap, activeDictionaries } = window.dictionaryContext;
        const dictionariesToProcess = Object.keys(activeDictionaries);

        dictionariesToProcess.forEach(dictionaryName => {
            if (!collapsibleSelectors[dictionaryName]) return;

            const currentSelectors = collapsibleSelectors[dictionaryName];
            const entries = document.querySelectorAll(`li[data-dictionary="${dictionaryName}"]`);

            if (entries.length > 0) {
                entries.forEach(entry => {
                    processElementsWithSelectors(entry, currentSelectors, displayNameMap);
                });
            }
            // Process single dictionary case
            else {
                processElementsWithSelectors(document, currentSelectors, displayNameMap);
            }
        });

        // Apply styles after a minimal delay to ensure elements are processed
        setTimeout(() => {
            // Remove the initial display:none from collapsible contents
            document.querySelectorAll('.collapsible-content').forEach(content => {
                content.style.display = '';
            });
            forceRedraw();
        }, 10);
    }

    // Helper function for collapsible elements
    function processElementsWithSelectors(container, selectors, displayNameMap) {
        selectors.forEach(selector => {
            const elements = container.querySelectorAll(selector);

            elements.forEach(element => {
                if (element.parentNode && element.parentNode.classList &&
                    element.parentNode.classList.contains('collapsible-content')) {
                    return;
                }

                const attrMatch = selector.match(/data-sc([^=\]]*)/);
                const rawAttrName = attrMatch ? attrMatch[1] : selector.split('[')[1].split(']')[0];
                const displayName = displayNameMap[rawAttrName] || rawAttrName;

                const wrapper = document.createElement('div');
                wrapper.className = 'collapsible-wrapper collapsed';

                const header = document.createElement('div');
                header.className = 'collapsible-header';
                header.textContent = displayName;

                const content = document.createElement('div');
                content.className = 'collapsible-content';
                // Start with display: none to avoid flash
                content.style.display = 'none';

                element.parentNode.insertBefore(wrapper, element);
                wrapper.appendChild(header);
                wrapper.appendChild(content);
                content.appendChild(element);
            });
        });
    }

    // Helper function to force CSS redraw for collapsible elements
    function forceRedraw() {
        document.querySelectorAll('.collapsible-wrapper').forEach(wrapper => {
            wrapper.classList.add('force-redraw');
            setTimeout(() => wrapper.classList.remove('force-redraw'), 10);
        });
    }

    // Feature: Show only the first image in dictionary entries
    function handleImages() {
        const { imageSelectors, activeDictionaries } = window.dictionaryContext;
        if (!Object.keys(activeDictionaries).length) return;

        function hideExtraImages(container, selector) {
            const images = container.querySelectorAll(selector);
            if (images.length > 1) {
                images.forEach((img, idx) => {
                    if (idx > 0) img.style.display = "none";
                });
            }
        }

        // Handle <li> dictionary entries
        for (const dictName of Object.keys(activeDictionaries)) {
            const selector = imageSelectors[dictName] || imageSelectors["default"];
            document.querySelectorAll(`li[data-dictionary="${dictName}"]`)
                .forEach(entry => hideExtraImages(entry, selector));
        }

        // Handle single dictionary entry layout
        const dictnameEl = window.dictionaryContext.elements.dictname;
        if (dictnameEl) {
            const singleDict = dictnameEl.textContent.trim();
            if (activeDictionaries[singleDict]) {
                const selector = imageSelectors[singleDict] || imageSelectors["default"];
                hideExtraImages(document, selector);
            }
        }
    }

    // Set up global event listeners
    function setupGlobalEventListeners() {
        let resizeTimer;
        window.addEventListener('resize', function () {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function () {
                window.dictionaryContext.detectVerticalMode();
                adjustCyclablePositions();
                forceRedraw();
            }, 250);
        });

        // Add click handlers for collapsible headers - done once globally
        document.addEventListener('click', function (e) {
            if (e.target && e.target.classList.contains('collapsible-header')) {
                const wrapper = e.target.closest('.collapsible-wrapper');
                if (wrapper) {
                    wrapper.classList.toggle('collapsed');
                }
            }
        });
    }

    // Use MutationObserver to wait for dictionary content to be fully loaded
    function waitForDictionaryContent() {
        const criticalElements = ['definition', 'content-container', 'dictname'];
        let elementsReady = 0;

        // Check if all critical elements are ready
        function checkReadiness() {
            elementsReady = 0;
            for (const id of criticalElements) {
                if (document.getElementById(id)) {
                    elementsReady++;
                }
            }
            return elementsReady === criticalElements.length;
        }

        // Init if everything is already ready
        if (checkReadiness()) {
            initializeDictionaryCard();
            return;
        }

        // Otherwise, set up a MutationObserver to wait
        const observer = new MutationObserver((mutations) => {
            if (checkReadiness()) {
                observer.disconnect();
                initializeDictionaryCard();
            }
        });

        // Start observing the document for added nodes
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Fallback: initialize after a timeout even if not all elements are ready
        setTimeout(() => {
            observer.disconnect();
            if (!checkReadiness()) {
                console.warn('Some dictionary elements not found, initializing anyway');
            }
            initializeDictionaryCard();
        }, 1000);
    }

    // Start the initialization process
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', waitForDictionaryContent);
    } else {
        waitForDictionaryContent();
    }
</script>
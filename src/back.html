<div class="center-wrapper back">
    <div id="container">
        <div id="dictname" style="position: relative; right: 0; top: 0; margin-bottom: 0.5em;">{{DictionaryName}}</div>

        <div id="header-container">
            <div class="audio-buttons">
                <div class="word-audio">{{Audio}}</div>
                <div class="sentence-audio">{{SentenceAudio}}</div>
            </div>
            <div class="header-main-content">
                <div id="expression">{{Word}}</div>
                <div id="reading">{{Reading}}</div>
            </div>
        </div>

        <div id="content-container">
            <div id="glossary-container">
                <div id="definition">{{Glossary}}</div>
                <div id="sentence">{{Sentence}}</div>
            </div>

            <div id="image-container">
                <div id="image">{{Picture}}</div>
            </div>
        </div>
    </div>
</div>

<script>
    // Main dictionary context object
    window.dictionaryContext = {
        cssFiles: {
            "三省堂 全訳読解古語辞典": "_skogo_anki.css",
            "旺文社 全訳古語辞典": "_ozk5_anki.css",
            "角川新字源 改訂新版": "_shinjigen_anki.css",
            "明鏡国語辞典 第三版": "_meikyo_anki.css"
        },

        collapsibleSelectors: {
            "三省堂 全訳読解古語辞典": [
                "div[data-sc絵巻項目]",
                "div[data-sc読解-g]"
            ],
            "旺文社 全訳古語辞典": [
                "div[data-sc用例囲み-g]",
                "div[data-sc発展]"
            ]
        },

        displayNameMap: {
            // 三省堂 全訳読解古語辞典
            "絵巻項目": "絵巻",
            "発展": "発展事項",
            "読解-g": "読解",

            // 旺文社 全訳古語辞典
            "用例囲み-g": "例文・訳"
        },

        imageSelectors: {
            "三省堂 全訳読解古語辞典": "div[data-sc画像-g]",
            "大辞泉 第二版": "div[data-sc-m-image]",

            // Default selectors
            "default": "div[data-sc画像-g], .image-container, .figure, figure, .img-container"
        },

        elements: {
            dictionaryEntries: null,
            collapsibleContents: null,
            definitionContainer: null,
            contentContainer: null,
            dictname: null,
            expression: null,
            reading: null,
            sentence: null,
            imageDiv: null,
            imageContainer: null,
            centerWrapperBack: null
        },

        activeDictionaries: {},
        isVertical: false,

        detectVerticalMode() {
            const wasVertical = this.isVertical;
            this.isVertical = window.getComputedStyle(document.body).writingMode === 'vertical-rl';

            // Only modify classes if the mode has changed
            if (wasVertical !== this.isVertical) {
                document.body.classList.toggle('vertical-mode', this.isVertical);

                // Apply to content container
                if (this.elements.contentContainer) {
                    this.elements.contentContainer.classList.toggle('vertical-mode', this.isVertical);
                }
            }

            return this.isVertical;
        },

        cacheElements() {
            // Cache common elements in a single pass
            const elementsToCache = {
                dictionaryEntries: "li[data-dictionary]",
                definitionContainer: "definition",
                contentContainer: "content-container",
                dictname: "dictname",
                expression: "expression",
                reading: "reading",
                sentence: "sentence",
                imageDiv: "image",
                imageContainer: "image-container",
                centerWrapperBack: ".center-wrapper.back"
            };

            // Process id-based selectors
            for (const [key, selector] of Object.entries(elementsToCache)) {
                if (selector.startsWith("#")) {
                    this.elements[key] = document.querySelector(selector);
                } else if (selector.startsWith(".")) {
                    this.elements[key] = document.querySelector(selector);
                } else if (selector.includes("[")) {
                    this.elements[key] = document.querySelectorAll(selector);
                } else {
                    this.elements[key] = document.getElementById(selector);
                }
            }

            // Cache collapsible contents separately as it might be dynamically created later
            this.elements.collapsibleContents = document.querySelectorAll('.collapsible-content');
        },

        identifyActiveDictionaries() {
            // Skip if already identified
            if (Object.keys(this.activeDictionaries).length > 0) {
                return Object.keys(this.activeDictionaries);
            }

            this.activeDictionaries = {};

            // Find dictionaries from list items
            const entries = this.elements.dictionaryEntries;
            if (entries && entries.length > 0) {
                entries.forEach((entry) => {
                    const dictName = entry.getAttribute("data-dictionary");
                    if (dictName) {
                        this.activeDictionaries[dictName] = true;
                    }
                });
            }
            // If no dictionaries found in list items, check the DictionaryName field
            else if (this.elements.dictname && this.elements.dictname.textContent.trim()) {
                const dictionaryName = this.elements.dictname.textContent.trim();
                this.activeDictionaries[dictionaryName] = true;
            }

            return Object.keys(this.activeDictionaries);
        },

        init() {
            this.cacheElements();
            this.detectVerticalMode();
            this.identifyActiveDictionaries();
        }
    };

    function initializeDictionaryCard() {
        window.dictionaryContext.init();

        // Run the features that have their required elements
        const ctx = window.dictionaryContext;
        const features = [
            // Only run features if their required elements exist
            { fn: handleEmptySentence, requires: ['sentence'] },
            { fn: handleDuplicateContent, requires: ['expression', 'reading', 'sentence'] },
            { fn: loadDictionaryCssFiles, requires: [] },
            { fn: setupCyclableDefinitions, requires: ['definitionContainer'] },
            { fn: setupCollapsibleElements, requires: [] },
            { fn: handleImages, requires: [] },
            { fn: hideEmptyImageContainer, requires: ['imageContainer', 'imageDiv'] },
            { fn: setupAdaptiveMargin, requires: ['contentContainer', 'centerWrapperBack'] }
        ];

        // Batch DOM reads first
        const elementsExist = {};
        for (const key in ctx.elements) {
            elementsExist[key] = ctx.elements[key] !== null &&
                !(ctx.elements[key] instanceof NodeList && ctx.elements[key].length === 0);
        }

        const pendingOperations = [];

        // Check which features to run
        features.forEach(feature => {
            const canRun = feature.requires.every(elem => elementsExist[elem]);
            if (canRun) {
                pendingOperations.push(feature.fn);
            }
        });

        // Batch DOM writes with requestAnimationFrame
        requestAnimationFrame(() => {
            pendingOperations.forEach(operation => operation());

            // Setup event listeners after all DOM operations
            setupGlobalEventListeners();
        });
    }

    // Feature: Hide image container if it's empty
    function hideEmptyImageContainer() {
        const { imageDiv, imageContainer } = window.dictionaryContext.elements;

        if (!imageContainer) return;

        // Check if the image div is empty or only contains whitespace
        const isEmpty = !imageDiv ||
            (imageDiv.getElementsByTagName('img').length === 0 &&
                imageDiv.innerText.trim() === '');

        // Hide the container if empty
        if (isEmpty) {
            imageContainer.style.display = 'none';
        }
    }

    // Feature: Hide sentence field if empty
    function handleEmptySentence() {
        const sentenceDiv = window.dictionaryContext.elements.sentence;
        if (sentenceDiv && sentenceDiv.textContent.trim() === "") {
            sentenceDiv.style.display = "none";
        }
    }

    // Feature: Hide reading and sentence if same as term
    function handleDuplicateContent() {
        const { expression, reading, sentence } = window.dictionaryContext.elements;

        // Batch DOM reads
        const expressionText = expression ? expression.textContent.trim() : null;
        const readingText = reading ? reading.textContent.trim() : null;
        const sentenceText = sentence ? sentence.textContent.trim() : null;

        const changes = [];

        if (expression && reading && expressionText === readingText) {
            changes.push(() => reading.style.display = "none");
        }

        if (expression && sentence && expressionText === sentenceText) {
            changes.push(() => sentence.style.display = "none");
        }

        // Apply all changes at once
        if (changes.length > 0) {
            requestAnimationFrame(() => {
                changes.forEach(change => change());
            });
        }
    }

    // Feature: Load dictionary CSS files for dictionaries
    function loadDictionaryCssFiles() {
        const { cssFiles, activeDictionaries } = window.dictionaryContext;
        const dictionariesToProcess = Object.keys(activeDictionaries);

        if (dictionariesToProcess.length === 0) return;

        // Create a document fragment for batch insertion
        const fragment = document.createDocumentFragment();

        dictionariesToProcess.forEach(dictionaryName => {
            if (cssFiles[dictionaryName]) {
                // Check if the CSS is already loaded
                const existingLink = document.querySelector(`link[href="${cssFiles[dictionaryName]}"]`);
                if (!existingLink) {
                    const link = document.createElement("link");
                    link.rel = "stylesheet";
                    link.href = cssFiles[dictionaryName];
                    fragment.appendChild(link);
                }
            }
        });

        // Add all links at once
        if (fragment.childNodes.length > 0) {
            document.head.appendChild(fragment);
        }
    }

    // Feature: Cyclable definitions
    function setupCyclableDefinitions() {
        const definitionContainer = window.dictionaryContext.elements.definitionContainer;
        if (!definitionContainer) return;

        const definitionItems = definitionContainer.querySelectorAll("li");
        if (definitionItems.length <= 1) return; // No need for cycling if only one definition

        // Create elements needed for cycling
        const fragment = document.createDocumentFragment();
        const counterElement = document.createElement("div");
        const leftEdge = document.createElement("div");
        const rightEdge = document.createElement("div");

        counterElement.className = "definition-counter";
        leftEdge.className = "definition-left-edge";
        rightEdge.className = "definition-right-edge";

        fragment.appendChild(counterElement);
        fragment.appendChild(leftEdge);
        fragment.appendChild(rightEdge);

        const containerToUse = window.dictionaryContext.elements.contentContainer || definitionContainer;
        containerToUse.style.position = "relative";

        // Set initial state - hide all definitions except the first one
        let currentIndex = 0;
        for (let i = 1; i < definitionItems.length; i++) {
            definitionItems[i].style.display = "none";
        }

        // Set counter text
        counterElement.textContent = `1/${definitionItems.length}`;

        // Batch DOM manipulation
        requestAnimationFrame(() => {
            containerToUse.appendChild(fragment);
            adjustCyclablePositions();
        });

        // Function to cycle to the next definition - Will run on user interaction, not during init
        function cycleDefinition(direction) {
            // Cache the elements for performance
            const oldElement = definitionItems[currentIndex];

            // Calculate new index
            currentIndex = direction === "next"
                ? (currentIndex + 1) % definitionItems.length
                : (currentIndex - 1 + definitionItems.length) % definitionItems.length;

            const newElement = definitionItems[currentIndex];

            // Batch the DOM updates
            requestAnimationFrame(() => {
                oldElement.style.display = "none";
                newElement.style.display = "";
                counterElement.textContent = `${currentIndex + 1}/${definitionItems.length}`;
            });
        }

        // Add click events to the edges
        leftEdge.addEventListener("click", () => cycleDefinition("prev"));
        rightEdge.addEventListener("click", () => cycleDefinition("next"));

        // Function to handle arrow key navigation
        function handleArrowKeys(event) {
            if (event.key === "ArrowLeft" || event.keyCode === 37) {
                cycleDefinition("prev");
            } else if (event.key === "ArrowRight" || event.keyCode === 39) {
                cycleDefinition("next");
            }
        }

        document.addEventListener("keydown", handleArrowKeys);
    }

    // Helper function for cyclable definitions positioning
    function adjustCyclablePositions() {
        const isVertical = window.dictionaryContext.isVertical;
        const containerToUse = window.dictionaryContext.elements.contentContainer ||
            window.dictionaryContext.elements.definitionContainer;

        if (containerToUse) {
            containerToUse.classList.toggle("vertical-mode", isVertical);
        }
    }

    // Feature: Adaptive margin for vertical layout
    function setupAdaptiveMargin() {
        if (!window.dictionaryContext.isVertical) return;

        const { contentContainer, centerWrapperBack } = window.dictionaryContext.elements;

        // Exit if required elements don't exist
        if (!contentContainer || !centerWrapperBack) return;

        // ===== CUSTOMIZABLE SETTINGS =====
        const NARROW_CONTENT_MAX = 300;  // Content narrower than this is considered "narrow"
        const MEDIUM_CONTENT_MAX = 600;  // Content between NARROW_MAX and this is "medium"

        const NARROW_CONTENT_CLAMP = {
            min: 16,   // Minimum margin in vw
            max: 30,   // Maximum margin in vw
            base: 16,  // Base value before viewport adjustment
            factor: 0.01  // How much to adjust per pixel of viewport width
        };

        const MEDIUM_CONTENT_CLAMP = {
            min: 10,
            max: 25,
            base: 10,
            factor: 0.01
        };

        const WIDE_CONTENT_CLAMP = {
            min: 4,
            max: 15,
            base: 4,
            factor: 0.007
        };

        const REFERENCE_VIEWPORT_WIDTH = 601;

        // Retina display adjustment
        const RETINA_ADJUSTMENT = 2;

        // Variable to store the last calculated margin to avoid unnecessary updates
        let lastCalculatedMargin = null;

        function calculateMargin() {
            // Read phase - gather all needed measurements
            const contentWidth = contentContainer.scrollWidth || contentContainer.offsetWidth;
            const viewportWidth = window.innerWidth;
            const isRetina = window.devicePixelRatio >= 2;

            let clampValues;

            if (contentWidth < NARROW_CONTENT_MAX) {
                clampValues = NARROW_CONTENT_CLAMP;
            }
            else if (contentWidth < MEDIUM_CONTENT_MAX) {
                clampValues = MEDIUM_CONTENT_CLAMP;
            }
            else {
                clampValues = WIDE_CONTENT_CLAMP;
            }

            // Calculate the preferred value based on viewport width
            const viewportAdjustment = (viewportWidth - REFERENCE_VIEWPORT_WIDTH) * clampValues.factor;
            const preferredMargin = clampValues.base + viewportAdjustment;

            let clampedMargin = Math.max(clampValues.min, Math.min(preferredMargin, clampValues.max));

            // Apply Retina adjustment if needed
            if (isRetina) {
                clampedMargin = Math.max(clampValues.min, clampedMargin - RETINA_ADJUSTMENT);
            }

            // Only update the DOM if the margin has changed
            if (lastCalculatedMargin !== clampedMargin) {
                lastCalculatedMargin = clampedMargin;

                // Write phase - update the DOM
                requestAnimationFrame(() => {
                    centerWrapperBack.style.marginRight = clampedMargin + 'vw';
                });
            }
        }

        // Initial calculation
        calculateMargin();

        // Optimize resize listener with debounce using requestAnimationFrame
        let resizeRAF = null;
        window.addEventListener('resize', () => {
            if (resizeRAF) {
                cancelAnimationFrame(resizeRAF);
            }
            resizeRAF = requestAnimationFrame(calculateMargin);
        });

        // Use a ResizeObserver for more efficient tracking of content changes
        if (window.ResizeObserver) {
            const resizeObserver = new ResizeObserver(() => {
                requestAnimationFrame(calculateMargin);
            });
            resizeObserver.observe(contentContainer);
            return resizeObserver;
        }

        // Fallback to MutationObserver if ResizeObserver isn't available
        const observer = new MutationObserver(() => {
            requestAnimationFrame(calculateMargin);
        });

        observer.observe(contentContainer, {
            childList: true,
            subtree: true,
            characterData: true,
            attributes: true
        });

        return observer;
    }

    // Feature: Collapsible elements
    function setupCollapsibleElements() {
        const { collapsibleSelectors, displayNameMap, activeDictionaries } = window.dictionaryContext;
        const dictionariesToProcess = Object.keys(activeDictionaries);

        if (dictionariesToProcess.length === 0) return;

        const allContentElements = [];
        const wrapperElements = [];

        // Read phase - identify and prepare elements
        dictionariesToProcess.forEach(dictionaryName => {
            const currentSelectors = collapsibleSelectors[dictionaryName];
            if (!currentSelectors) return;

            const entries = document.querySelectorAll(`li[data-dictionary="${dictionaryName}"]`);
            const container = entries.length > 0 ? entries : [document];

            container.forEach(ctx => {
                currentSelectors.forEach(selector => {
                    const elements = ctx.querySelectorAll(selector);
                    if (!elements.length) return;

                    const attrMatch = selector.match(/data-sc([^=\]]*)/);
                    const rawAttrName = attrMatch ? attrMatch[1] : selector.split('[')[1]?.split(']')[0];
                    if (!rawAttrName) return;

                    const displayName = displayNameMap[rawAttrName] || rawAttrName;

                    elements.forEach(el => {
                        // Avoid wrapping already-wrapped elements
                        const parent = el.parentNode;
                        if (parent && parent.classList?.contains('collapsible-content')) return;

                        // Prepare elements for batch processing
                        allContentElements.push({
                            element: el,
                            parent: parent,
                            displayName: displayName
                        });
                    });
                });
            });
        });

        // Skip if nothing to process
        if (allContentElements.length === 0) return;

        // Write phase - create and insert wrappers
        requestAnimationFrame(() => {
            // Use a document fragment for better performance with multiple elements
            allContentElements.forEach(item => {
                const { element, parent, displayName } = item;

                const wrapper = document.createElement('div');
                wrapper.className = 'collapsible-wrapper collapsed';

                const header = document.createElement('div');
                header.className = 'collapsible-header';
                header.textContent = displayName;

                const content = document.createElement('div');
                content.className = 'collapsible-content';

                // Hide initially for a smoother appearance
                content.style.display = 'none';

                parent.insertBefore(wrapper, element);
                wrapper.appendChild(header);
                wrapper.appendChild(content);
                content.appendChild(element);

                wrapperElements.push(wrapper);
            });

            // Force a redraw after the wrappers are created
            requestAnimationFrame(() => {
                wrapperElements.forEach(wrapper => {
                    const content = wrapper.querySelector('.collapsible-content');
                    if (content) {
                        content.style.display = '';
                    }
                });
                forceRedraw(wrapperElements);
            });
        });
    }

    // Helper function to force CSS redraw for collapsible elements
    function forceRedraw(wrappers = null) {
        const elements = wrappers || document.querySelectorAll('.collapsible-wrapper');
        if (elements.length === 0) return;

        // Add the force-redraw class
        requestAnimationFrame(() => {
            elements.forEach(wrapper => {
                wrapper.classList.add('force-redraw');
            });

            // Remove it in the next frame
            requestAnimationFrame(() => {
                elements.forEach(wrapper => {
                    wrapper.classList.remove('force-redraw');
                });
            });
        });
    }

    // Feature: Show only the first image in dictionary entries
    function handleImages() {
        const { imageSelectors, activeDictionaries } = window.dictionaryContext;
        const dictionaries = Object.keys(activeDictionaries);

        if (dictionaries.length === 0) return;

        // Batch operation for hiding images
        const imagesToHide = [];

        function collectExtraImages(container, selector) {
            const images = container.querySelectorAll(selector);
            if (images.length > 1) {
                for (let i = 1; i < images.length; i++) {
                    imagesToHide.push(images[i]);
                }
            }
        }

        // Handle <li> dictionary entries
        for (const dictName of dictionaries) {
            const selector = imageSelectors[dictName] || imageSelectors["default"];
            document.querySelectorAll(`li[data-dictionary="${dictName}"]`)
                .forEach(entry => collectExtraImages(entry, selector));
        }

        // Handle single dictionary entry layout
        const dictnameEl = window.dictionaryContext.elements.dictname;
        if (dictnameEl) {
            const singleDict = dictnameEl.textContent.trim();
            if (activeDictionaries[singleDict]) {
                const selector = imageSelectors[singleDict] || imageSelectors["default"];
                collectExtraImages(document, selector);
            }
        }

        // Apply all changes at once
        if (imagesToHide.length > 0) {
            requestAnimationFrame(() => {
                imagesToHide.forEach(img => {
                    img.style.display = "none";
                });
            });
        }
    }

    // Set up global event listeners
    function setupGlobalEventListeners() {
        // Optimize resize handler with requestAnimationFrame
        let resizeRAF = null;
        window.addEventListener('resize', function () {
            if (resizeRAF) {
                cancelAnimationFrame(resizeRAF);
            }

            resizeRAF = requestAnimationFrame(function () {
                window.dictionaryContext.detectVerticalMode();
                adjustCyclablePositions();
                forceRedraw();
            });
        });

        // Add click handlers for collapsible headers - done once globally with event delegation
        document.addEventListener('click', function (e) {
            if (e.target && e.target.classList.contains('collapsible-header')) {
                const wrapper = e.target.closest('.collapsible-wrapper');
                if (wrapper) {
                    wrapper.classList.toggle('collapsed');
                }
            }
        });
    }

    // Use MutationObserver to wait for dictionary content to be fully loaded
    function waitForDictionaryContent() {
        const criticalElements = ['definition', 'content-container', 'dictname'];

        // Check if all critical elements are ready
        function checkReadiness() {
            return criticalElements.every(id => document.getElementById(id));
        }

        // Init if everything is already ready
        if (checkReadiness()) {
            initializeDictionaryCard();
            return;
        }

        // Otherwise, set up a MutationObserver to wait
        const observer = new MutationObserver(() => {
            if (checkReadiness()) {
                observer.disconnect();
                initializeDictionaryCard();
            }
        });

        // Start observing the document for added nodes
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Fallback: initialize after a timeout even if not all elements are ready
        // Using requestAnimationFrame for more precise timing
        let frameCount = 0;
        function checkAfterFrames() {
            if (checkReadiness() || frameCount > 60) { // 60 frames ≈ 1 second at 60fps
                observer.disconnect();
                if (!checkReadiness()) {
                    console.warn('Some dictionary elements not found, initializing anyway');
                }
                initializeDictionaryCard();
            } else {
                frameCount++;
                requestAnimationFrame(checkAfterFrames);
            }
        }

        requestAnimationFrame(checkAfterFrames);
    }

    // Start the initialization process
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', waitForDictionaryContent);
    } else {
        waitForDictionaryContent();
    }
</script>
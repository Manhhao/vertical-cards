<div id="writing-mode-toggle-container">
    <label class="writing-mode-switch">
        <input type="checkbox" id="writing-mode-toggle" checked>
        <span class="slider round"></span>
        <span class="toggle-label"></span>
    </label>
</div>

<div class="center-wrapper">
    <div id="container">
        <div id="dictname">{{DictionaryName}}</div>

        <div id="top-section">
            <div id="header-container">
                <div class="header-main-content">
                    <div id="expression">{{Word}}</div>
                    <div id="reading">{{Reading}}</div>
                </div>
                <div class="audio-buttons">
                    {{#Audio}}
                    <div class="word-audio">
                        {{Audio}}
                        <span class="word-icon">字</span>
                    </div>
                    {{/Audio}}

                    {{#SentenceAudio}}
                    <div class="sentence-audio">
                        {{SentenceAudio}}
                        <span class="sentence-icon">〽</span>
                    </div>
                    {{/SentenceAudio}}
                </div>
            </div>

            <div id="image-container">
                <div class="image-edge-nav image-left-edge"></div>
                <div class="image-edge-nav image-right-edge"></div>
                <div id="image">
                    {{Picture}}
                </div>
            </div>
        </div>

        <div id="content-container" class="縦書き">
            <div id="glossary-container">
                <div id="definition">{{Glossary}}</div>
                <div id="sentence">{{Sentence}}</div>
            </div>
        </div>
    </div>
</div>

<div id="lightbox-overlay">
    <span id="lightbox-close">&times;</span>
    <img id="lightbox-image" src="" alt="">
</div>

<script>
    // CJK文字をカウントする関数
    function countCJKChars(text) {
        if (!text) return 0;
        // - Basic CJK Unified Ideographs (4E00-9FFF)
        // - CJK Extension A (3400-4DBF)
        // - CJK Extension B (20000-2A6DF)
        // - CJK Extension C (2A700-2B73F)
        // - CJK Extension D (2B740-2B81F)
        // - CJK Extension E (2B820-2CEAF)
        // - CJK Extension F (2CEB0-2EBEF)
        // - CJK Extension G (30000-3134F)
        // - CJK Extension H (31350-323AF)
        // - CJK Compatibility Ideographs (F900-FAFF)
        // - CJK Radicals Supplement (2E80-2EFF)
        // - CJK Strokes (31C0-31EF)
        // - Ideographic Description Characters (2FF0-2FFF)
        // - Hiragana (3040-309F)
        // - Katakana (30A0-30FF)
        // - Katakana Phonetic Extensions (31F0-31FF)
        // - Halfwidth Katakana (FF65-FF9F)
        // - Kanbun (3190-319F)

        const cjkBasic = /[\u4E00-\u9FFF]/;
        // surrogate pairs for UTF-32
        const cjkExtensions = /\uD840[\uDC00-\uDFFF]|[\uD841-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]|\uD869[\uDF00-\uDFFF]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF3F]|\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]|\uD86E[\uDC20-\uDFFF]|[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]|\uD873[\uDEB0-\uDFFF]|[\uD874-\uD879][\uDC00-\uDFFF]|\uD87A[\uDC00-\uDFEF]|\uD880[\uDC00-\uDFFF]|[\uD881-\uD883][\uDC00-\uDFFF]|\uD884[\uDC00-\uDF4F]|\uD884[\uDF50-\uDFFF]|[\uD885-\uD887][\uDC00-\uDFFF]|\uD888[\uDC00-\uDFAF]/;
        const cjkAdditional = /[\uF900-\uFAFF\u2E80-\u2EFF\u2FF0-\u2FFF]/;

        const basicMatches = text.match(cjkBasic);
        const extensionMatches = text.match(cjkExtensions);
        const additionalMatches = text.match(cjkAdditional);

        const basicCount = basicMatches ? basicMatches.length : 0;
        const extensionCount = extensionMatches ? extensionMatches.length : 0;
        const additionalCount = additionalMatches ? additionalMatches.length : 0;

        return basicCount + extensionCount + additionalCount;
    }


    // メイン辞書コンテキストオブジェクト
    window.dictionaryContext = {
        // 辞書クラス名マッピング
        dictionaryClassNames: {
            "三省堂 全訳読解古語辞典": "三省堂古語",
            "旺文社 全訳古語辞典": "旺文社古語",
            "角川新字源 改訂新版": "角川新字源",
            "明鏡国語辞典 第三版": "明鏡",
            "大辞泉 第二版": "大辞泉",
            "デジタル大辞泉": "大辞泉",
            "漢検漢字辞典　第二版": "漢検検定辞典",
            "新明解国語辞典　第八版": "新明解",
            "現代心理学辞典": "心理学辞典",
            "南山堂医学大辞典 第20版": "南山堂医学",
            "三省堂国語辞典　第八版": "三省堂国語",
            "旺文社国語辞典 第十一版": "旺文社国語",
            "大辞林　第四版": "大辞林",
            "精選版　日本国語大辞典": "精選版",
            "広辞苑 第七版": "広辞苑",

            //四字熟語
            "YOJI-JUKUGO": "YOJI",
            "四字熟語の百科事典": "四字百科",
            "新明解四字熟語辞典": "新明解四字",
            "学研 四字熟語辞典": "学研四字",
            "四字熟語辞典オンライン": "四字オンライン"
        },

        // 折りたたみ可能な要素のセレクター
        collapsibleSelectors: {
            "三省堂 全訳読解古語辞典": [
                {selector: "div[data-sc絵巻項目]", displayName: "絵巻"},
                {selector: "div[data-sc読解-g]", displayName: "読解"},
                {selector: "div[data-sc関連語sub-b]", displayName: "関連語"}
            ],
            "旺文社 全訳古語辞典": [
                {selector: "div[data-sc用例囲み-g]", displayName: "例文・訳"},
                {selector: "div[data-sc発展]", displayName: "発展事項"},
                {selector: "div[data-sc敬語ガイド]", displayName: "敬語ガイド"},
                {selector: "div:has(>div[data-sc図解学習タイトル])", displayName: "図解学習"}
            ],
            "四字熟語の百科事典": [
                {selector: "div[data-sc-name=\"使い方\"]", displayName: "使い方"}
            ],
            "四字熟語辞典オンライン": [
                {selector: "div[style=\"display:block;\"]>table", displayName: "詳細情報"}
            ]
        },

        // 画像要素のセレクター
        imageSelectors: {
            "三省堂 全訳読解古語辞典": "div[data-sc画像-g]",
            "大辞泉 第二版": "div[data-sc-m-image]",
            "現代心理学辞典": "div[data-sc-image]>div:has([data-sc-img])",
            "南山堂医学大辞典 第20版": "span[data-sc-scale-image]",
            "角川新字源 改訂新版": "div[data-sc-imagefile]",
            "明鏡国語辞典 第三版": "td[data-sc-img]",
            "デジタル大辞泉": "li:has(>a>span img)",
            "広辞苑 第七版": "div:has(>a>span)",
            "旺文社国語辞典 第十一版": "span>a>span",
            "漢字でGo! [2024-03-09]": "div:has(>a>span)",
            "default": "div[data-sc画像-g], .image-container, .figure, figure, .img-container"
        },

        elements: {},
        activeDictionaries: {},
        isVertical: false,
        initialized: false,
        userPreferences: {
            tategakiEnabled: true
        },

        // ユーザー設定とデバイス幅に基づいて縦書きモードを検出
        detectVerticalMode() {
            const contentContainer = this.elements.contentContainer;
            if (!contentContainer) return false;

            const isMobileView = window.innerWidth <= 600;
            this.isVertical = isMobileView ? false : this.userPreferences.tategakiEnabled;

            contentContainer.classList.toggle('縦書き', this.isVertical);
            contentContainer.classList.toggle('横書き', !this.isVertical);

            return this.isVertical;
        },

        // 文字方向切替
        toggleWritingMode(enabled) {
            this.userPreferences.tategakiEnabled = typeof enabled === 'boolean' ? enabled : !this.userPreferences.tategakiEnabled;
            localStorage.setItem('tategakiEnabled', this.userPreferences.tategakiEnabled);

            this.detectVerticalMode();

            const toggle = document.getElementById('writing-mode-toggle');
            if (toggle) toggle.checked = this.userPreferences.tategakiEnabled;

            this.showWritingModeToggle();

            window.dispatchEvent(new Event('resize'));
        },

        // 高速アクセスのためにDOM要素を保存
        cacheElements() {
            const selectors = {
                dictionaryEntries: {selector: "li[data-dictionary]", all: true},
                definitionContainer: {selector: "#definition"},
                contentContainer: {selector: "#content-container"},
                dictname: {selector: "#dictname"},
                expression: {selector: "#expression"},
                reading: {selector: "#reading"},
                sentence: {selector: "#sentence"},
                imageDiv: {selector: "#image"},
                imageContainer: {selector: "#image-container"},
                centerWrapperBack: {selector: ".center-wrapper.back"}
            };

            for (const [key, {selector, all}] of Object.entries(selectors)) {
                this.elements[key] = all ? document.querySelectorAll(selector) : document.querySelector(selector);
            }
        },

        // 切替ボタンを表示
        showWritingModeToggle() {
            const toggleContainer = document.getElementById('writing-mode-toggle-container');
            if (toggleContainer) {
                if (window.innerWidth > 600) {
                    toggleContainer.classList.add('ready');
                }
            }
        },

        //文字サイズを調整する
        adjustFontSize() {
            const expression = this.elements.expression;
            const reading = this.elements.reading;
            if (!expression || !reading) return;

            // 最小サイズ設定
            const minExpressionSize = 1.8;
            const minReadingSize = 0.9;

            // 最大サイズ（文字数が少ない時に使う）
            const maxExpressionSize = 2.5;
            const maxReadingSize = 1.2;

            const expressionText = expression.textContent;
            const readingText = reading.textContent;

            const expressionLength = countCJKChars(expressionText);
            const readingLength = countCJKChars(readingText);

            // 単語のサイズ調整
            let expressionSize;
            if (expressionLength === 1) {
                // 一文字なら最大サイズ
                expressionSize = maxExpressionSize;
            } else if (expressionLength <= 3) {
                // 2-3文字なら中間サイズ
                const scale = (expressionLength - 1) / 2;
                expressionSize = maxExpressionSize - (maxExpressionSize - minExpressionSize) * scale;
            } else {
                // 4文字以上なら最小サイズ
                expressionSize = minExpressionSize;
            }

            // 読み方のサイズ調整
            let readingSize;
            if (readingLength === 0) {
                readingSize = minReadingSize;
            } else if (readingLength <= 4) {
                readingSize = maxReadingSize - (maxReadingSize - minReadingSize) * ((readingLength - 1) / 3);
            } else {
                readingSize = minReadingSize;
            }

            // 実際にサイズを適用
            expression.style.fontSize = `${expressionSize}em`;
            reading.style.fontSize = `${readingSize}em`;
        },

        // 現在アクティブな辞書を調べる
        identifyActiveDictionaries() {
            if (Object.keys(this.activeDictionaries).length > 0) {
                return Object.keys(this.activeDictionaries);
            }

            this.activeDictionaries = {};
            const {dictionaryEntries, dictname} = this.elements;

            if (dictionaryEntries && dictionaryEntries.length > 0) {
                dictionaryEntries.forEach(entry => {
                    const dictName = entry.getAttribute("data-dictionary");
                    if (dictName) this.activeDictionaries[dictName] = true;
                });
            } else if (dictname && dictname.textContent.trim()) {
                this.activeDictionaries[dictname.textContent.trim()] = true;
            }

            return Object.keys(this.activeDictionaries);
        },

        // 辞書ごとのスタイルを適用
        applyDictionaryClasses() {
            const {dictionaryClassNames, activeDictionaries, elements} = this;
            const dictionariesToProcess = Object.keys(activeDictionaries);

            if (dictionariesToProcess.length === 0) return;

            const {dictionaryEntries, definitionContainer, dictname} = elements;

            // 単一辞書の場合のリスト構造の確認と構築
            if (definitionContainer && dictionariesToProcess.length === 1) {
                const dictName = dictionariesToProcess[0];

                // 既存のリスト項目がない場合は、リスト構造を作成します
                const existingListItems = definitionContainer.querySelectorAll("li[data-dictionary]");
                if (existingListItems.length === 0 && dictname) {
                    const actualDictName = dictname.textContent.trim();
                    if (!actualDictName) return;

                    // パフォーマンス向上のためにドキュメントフラグメントを使う
                    const fragment = document.createDocumentFragment();

                    // リスト構造を作成
                    const listElement = document.createElement("ol");
                    listElement.className = "dictionary-list";

                    // リストアイテム作成
                    const listItem = document.createElement("li");
                    listItem.setAttribute("data-dictionary", actualDictName);

                    // 現在の内容を取得
                    const currentContent = definitionContainer.innerHTML;

                    // 辞書クラスを適用
                    if (dictionaryClassNames[actualDictName]) {
                        listItem.classList.add(dictionaryClassNames[actualDictName]);
                    }

                    // Pixiv辞書は特別扱い
                    else if (actualDictName.startsWith('Pixiv')) {
                        listItem.classList.add('pixiv');
                    } else if (actualDictName.startsWith('漢字でGo')) {
                        listItem.classList.add('漢字でGo');
                    }

                    listItem.innerHTML = currentContent;
                    listElement.appendChild(listItem);
                    fragment.appendChild(listElement);

                    // コンテナクラスを更新
                    definitionContainer.className = "yomitan-glossary";

                    // コンテナをクリアして、フラグメントを挿入
                    definitionContainer.innerHTML = "";
                    definitionContainer.appendChild(fragment);

                    // 要素を更新
                    this.elements.dictionaryEntries = definitionContainer.querySelectorAll("li[data-dictionary]");
                } else if (dictName.startsWith('Pixiv')) {
                    definitionContainer.classList.add('pixiv');
                } else if (dictName.startsWith('漢字でGo')) {
                    definitionContainer.classList.add('漢字でGo');
                } else if (dictionaryClassNames[dictName]) {
                    definitionContainer.classList.add(dictionaryClassNames[dictName]);
                }
            }

            // 各辞書エントリにクラスを適用
            if (this.elements.dictionaryEntries && this.elements.dictionaryEntries.length > 0) {
                this.elements.dictionaryEntries.forEach(entry => {
                    const dictName = entry.getAttribute("data-dictionary");
                    if (dictName) {
                        if (dictionaryClassNames[dictName]) {
                            entry.classList.add(dictionaryClassNames[dictName]);
                        } else if (dictName.startsWith('Pixiv')) {
                            entry.classList.add('pixiv');
                        } else if (dictName.startsWith('漢字でGo')) {
                            entry.classList.add('漢字でGo')
                        }
                    }
                });
            }
        },

        // 初期化処理
        init() {
            if (this.initialized) return;

            // 保存された設定を読み込み
            const savedPreference = localStorage.getItem('tategakiEnabled');
            if (savedPreference !== null) {
                this.userPreferences.tategakiEnabled = savedPreference === 'true';
            }

            this.cacheElements();
            this.identifyActiveDictionaries();
            this.applyDictionaryClasses();
            this.detectVerticalMode();
            this.adjustFontSize();

            const toggle = document.getElementById('writing-mode-toggle');
            if (toggle) toggle.checked = this.userPreferences.tategakiEnabled;

            // ちょっと待ってから切り替えボタンを表示
            setTimeout(() => this.showWritingModeToggle(), 50);

            this.initialized = true;
        }
    };

    // 辞書カードを初期化
    function initializeDictionaryCard() {
        if (!window.dictionaryContext) return;

        window.dictionaryContext.init();

        const ctx = window.dictionaryContext;

        // 画像要素をキャッシュ
        if (!ctx.elements.imageDiv) {
            ctx.elements.imageDiv = document.querySelector('#image');
        }

        if (!ctx.elements.imageContainer) {
            ctx.elements.imageContainer = document.querySelector('#image-container');
        }

        // 存在する要素をチェック
        const elementsExist = {};
        for (const key in ctx.elements) {
            elementsExist[key] = ctx.elements[key] !== null &&
                !(ctx.elements[key] instanceof NodeList && ctx.elements[key].length === 0);
        }

        // 必要な処理をまとめて実行
        requestAnimationFrame(() => {
            if (elementsExist.sentence) handleEmptySentence();
            if (elementsExist.expression && elementsExist.reading && elementsExist.sentence) handleDuplicateContent();
            if (elementsExist.definitionContainer) setupCyclableDefinitions();
            setupCollapsibleElements();
            handleImages();
            setupWritingModeToggle();

            setupGlobalEventListeners();
        });
    }

    // 縦書き切り替えボタンの設定
    function setupWritingModeToggle() {
        const toggle = document.getElementById('writing-mode-toggle');
        if (!toggle) return;

        toggle.checked = window.dictionaryContext.userPreferences.tategakiEnabled;

        toggle.addEventListener('change', function () {
            window.dictionaryContext.toggleWritingMode(this.checked);
        });

        // モバイルでは切替を非表示
        if (window.innerWidth <= 600) {
            toggle.parentElement.parentElement.style.display = 'none';
        }
    }

    // 空の画像コンテナを非表示
    function hideEmptyImageContainer() {
        const {imageDiv, imageContainer} = window.dictionaryContext.elements;
        if (!imageContainer || !imageDiv) return;

        const hasImages = imageDiv.getElementsByTagName('img').length > 0;
        const hasText = imageDiv.innerText.trim() !== '';

        if (!hasImages && !hasText) {
            imageContainer.style.display = 'none';
        }
    }

    // 空の例文フィールドを非表示
    function handleEmptySentence() {
        const sentenceDiv = window.dictionaryContext.elements.sentence;
        if (sentenceDiv && sentenceDiv.textContent.trim() === "") {
            sentenceDiv.style.display = "none";
        }
    }

    // 重複コンテンツを非表示
    function handleDuplicateContent() {
        const {expression, reading, sentence} = window.dictionaryContext.elements;
        if (!expression) return;

        const expressionText = expression.textContent.trim();
        const readingText = reading ? reading.textContent.trim() : null;
        const sentenceText = sentence ? sentence.textContent.trim() : null;

        if (reading && expressionText === readingText) {
            reading.style.display = "none";
        }

        if (sentence && expressionText === sentenceText) {
            sentence.style.display = "none";
        }
    }

    // 複数辞書のページング機能
    function setupCyclableDefinitions() {
        const definitionContainer = window.dictionaryContext.elements.definitionContainer;
        if (!definitionContainer) return;

        const definitionItems = Array.from(definitionContainer.querySelectorAll("li[data-dictionary]"));
        if (definitionItems.length <= 1) return;

        const containerToUse = window.dictionaryContext.elements.contentContainer || definitionContainer;
        containerToUse.style.position = "relative";

        // スマホかどうか判定
        const isMobileDevice = document.documentElement.classList.contains('mobile');

        // モバイルデバイス用のクラスを追加
        if (isMobileDevice) {
            containerToUse.classList.add('mobile-device');
        }

        // ナビゲーション用HTML
        const navHTML = `
        <div class="definition-counter"></div>
        <div class="definition-left-edge" role="button" aria-label="前の定義"></div>
        <div class="definition-right-edge" role="button" aria-label="次の定義"></div>
    `;

        containerToUse.insertAdjacentHTML('beforeend', navHTML);

        const counterElement = containerToUse.querySelector('.definition-counter');
        const leftEdge = containerToUse.querySelector('.definition-left-edge');
        const rightEdge = containerToUse.querySelector('.definition-right-edge');

        let currentStartIndex = 0;
        let visibleCount = 1;
        const totalDefinitions = definitionItems.length;

        let lastMeasuredWidth = 0;
        let lastMeasuredHeight = 0;
        let hasCalculatedInitialLayout = false;

        // 表示可能な定義数を計算
        function calculateVisibleCount() {
            window.dictionaryContext.detectVerticalMode();
            const isVertical = window.dictionaryContext.isVertical;

            if (!isVertical) {
                const sentenceEl = document.getElementById('sentence');
                const viewportHeight = window.innerHeight;

                let sentenceHeight = 0;
                if (sentenceEl && sentenceEl.style.display !== 'none') {
                    const sentenceRect = sentenceEl.getBoundingClientRect();
                    sentenceHeight = sentenceRect.height;
                }

                const otherContentHeight = sentenceHeight || 50;
                const maxHeight = viewportHeight * 0.65;
                const availableHeight = Math.max(50, maxHeight - otherContentHeight);

                definitionItems.forEach(item => {
                    item.style.display = "";
                    item.style.visibility = "hidden";
                });

                containerToUse.offsetHeight;

                let count = 0;
                let totalHeight = 0;

                for (let i = 0; i < definitionItems.length; i++) {
                    const item = definitionItems[i];
                    const itemRect = item.getBoundingClientRect();
                    const itemStyle = window.getComputedStyle(item);

                    const itemHeight = itemRect.height +
                        parseFloat(itemStyle.marginTop) +
                        parseFloat(itemStyle.marginBottom);

                    const itemWithBuffer = itemHeight * 1.1;

                    if (totalHeight + itemWithBuffer <= availableHeight || i === 0) {
                        totalHeight += itemWithBuffer;
                        count++;
                    } else {
                        break;
                    }
                }

                definitionItems.forEach(item => {
                    item.style.visibility = "";
                    item.style.display = "none";
                });

                return Math.max(1, Math.min(count, totalDefinitions));
            }

            const containerRect = containerToUse.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;

            if (containerWidth === lastMeasuredWidth &&
                containerHeight === lastMeasuredHeight &&
                hasCalculatedInitialLayout) {
                return visibleCount;
            }

            lastMeasuredWidth = containerWidth;
            lastMeasuredHeight = containerHeight;

            definitionItems.forEach(item => {
                item.style.display = "";
                item.style.visibility = "hidden";
            });

            const containerSize = containerWidth;
            const safetyMargin = 0.9;
            const usableSpace = containerSize * safetyMargin;

            let totalUsedSpace = 0;
            let count = 0;

            for (const item of definitionItems) {
                const itemRect = item.getBoundingClientRect();
                const style = window.getComputedStyle(item);

                const itemSize = itemRect.width +
                    parseFloat(style.marginLeft) +
                    parseFloat(style.marginRight);

                if (totalUsedSpace + itemSize > usableSpace) break;

                totalUsedSpace += itemSize;
                count++;
            }

            definitionItems.forEach(item => {
                item.style.visibility = "";
                item.style.display = "none";
            });

            hasCalculatedInitialLayout = true;
            return Math.max(1, count);
        }

        // 表示する定義を更新
        function updateVisibleDefinitions() {
            definitionItems.forEach(item => item.style.display = "none");

            const actualVisibleCount = Math.min(visibleCount, totalDefinitions - currentStartIndex);
            for (let i = 0; i < actualVisibleCount; i++) {
                definitionItems[currentStartIndex + i].style.display = "";
            }

            const endIndex = currentStartIndex + actualVisibleCount - 1;

            if (visibleCount >= totalDefinitions) {
                counterElement.textContent = "全てを表示";
            } else if (actualVisibleCount === 1) {
                counterElement.textContent = `(${currentStartIndex + 1}/${totalDefinitions})`;
            } else {
                counterElement.textContent = `(${currentStartIndex + 1}-${endIndex + 1}/${totalDefinitions})`;
            }

            const showNavigation = visibleCount < totalDefinitions;
            leftEdge.style.display = rightEdge.style.display = showNavigation ? "" : "none";
        }

        // コンテナの高さ調整
        function adjustContainerHeight() {
            if (window.dictionaryContext.isVertical) return;

            const visibleItems = definitionItems.filter(item => item.style.display === "");
            if (visibleItems.length === 0) return;

            const sentenceEl = document.getElementById('sentence');
            const contentContainerEl = containerToUse.closest('#content-container');

            if (!contentContainerEl) return;

            const containerRect = contentContainerEl.getBoundingClientRect();

            contentContainerEl.style.minHeight = '';

            let lastElement = null;
            let lastElementRect = null;

            if (sentenceEl && sentenceEl.style.display !== 'none') {
                lastElement = sentenceEl;
            } else if (visibleItems.length > 0) {
                lastElement = visibleItems[visibleItems.length - 1];
            }

            if (lastElement) {
                contentContainerEl.offsetHeight;

                lastElementRect = lastElement.getBoundingClientRect();
                const requiredHeight = lastElementRect.bottom - containerRect.top + 20;
                contentContainerEl.style.minHeight = `${Math.max(requiredHeight, 100)}px`;
            }
        }

        // 定義を切り替える
        function cycleDefinitions(direction) {
            if (visibleCount >= totalDefinitions) return;

            const totalGroups = Math.ceil(totalDefinitions / visibleCount);
            const currentGroupIndex = Math.floor(currentStartIndex / visibleCount);

            if (direction === "next") {
                const nextGroupIndex = (currentGroupIndex + 1) % totalGroups;
                currentStartIndex = nextGroupIndex * visibleCount;
            } else {
                const prevGroupIndex = (currentGroupIndex - 1 + totalGroups) % totalGroups;
                currentStartIndex = prevGroupIndex * visibleCount;
            }

            updateVisibleDefinitions();
            setTimeout(() => adjustContainerHeight(), 10);
        }

        // 連続クリック対策
        function debounce(func, wait) {
            let timeout;
            return function () {
                clearTimeout(timeout);
                timeout = setTimeout(func, wait);
            };
        }

        // タッチ操作用の変数
        let touchActive = false;
        let touchTimeout = null;

        // タッチ開始時の処理
        function handleTouchStart(element) {
            return function (e) {
                element.classList.add('touch-active');
                touchActive = true;

                if (touchTimeout) {
                    clearTimeout(touchTimeout);
                    touchTimeout = null;
                }
            };
        }

        // タッチ終了時の処理
        function handleTouchEnd(element, direction) {
            return function (e) {
                if (touchActive) {
                    cycleDefinitions(direction);

                    touchTimeout = setTimeout(() => {
                        element.classList.remove('touch-active');
                        touchActive = false;
                    }, 300);
                }
            };
        }

        // タッチキャンセル時の処理
        function handleTouchCancel(element) {
            return function (e) {
                element.classList.remove('touch-active');
                touchActive = false;

                if (touchTimeout) {
                    clearTimeout(touchTimeout);
                    touchTimeout = null;
                }
            };
        }

        // クリックとタッチイベントを設定
        leftEdge.addEventListener("click", () => cycleDefinitions("prev"));
        rightEdge.addEventListener("click", () => cycleDefinitions("next"));

        leftEdge.addEventListener("touchstart", handleTouchStart(leftEdge), {passive: true});
        leftEdge.addEventListener("touchend", handleTouchEnd(leftEdge, "prev"), {passive: true});
        leftEdge.addEventListener("touchcancel", handleTouchCancel(leftEdge), {passive: true});

        rightEdge.addEventListener("touchstart", handleTouchStart(rightEdge), {passive: true});
        rightEdge.addEventListener("touchend", handleTouchEnd(rightEdge, "next"), {passive: true});
        rightEdge.addEventListener("touchcancel", handleTouchCancel(rightEdge), {passive: true});

        // キーボード操作もサポート
        document.addEventListener("keydown", (event) => {
            if (event.key === "ArrowLeft" || event.keyCode === 37) {
                cycleDefinitions("prev");
            } else if (event.key === "ArrowRight" || event.keyCode === 39) {
                cycleDefinitions("next");
            }
        }, {passive: true});

        // 初期表示
        counterElement.textContent = `(1/${totalDefinitions})`;
        leftEdge.style.display = rightEdge.style.display = totalDefinitions > 1 ? "" : "none";

        // 初期計算
        const scheduleInitialCalculation = window.requestIdleCallback || requestAnimationFrame;
        scheduleInitialCalculation(() => {
            visibleCount = calculateVisibleCount();
            updateVisibleDefinitions();
            adjustContainerHeight();
        });

        // リサイズ時の処理
        const debouncedResize = debounce(() => {
            visibleCount = calculateVisibleCount();
            updateVisibleDefinitions();
            adjustContainerHeight();
        }, 250);

        window.addEventListener('resize', debouncedResize, {passive: true});

        // 表示モード変更時の処理
        const originalDetectVerticalMode = window.dictionaryContext.detectVerticalMode;
        window.dictionaryContext.detectVerticalMode = function () {
            const wasVertical = this.isVertical;
            const result = originalDetectVerticalMode.call(this);

            if (wasVertical !== this.isVertical) {
                lastMeasuredWidth = lastMeasuredHeight = 0;

                setTimeout(() => {
                    requestAnimationFrame(() => {
                        visibleCount = calculateVisibleCount();
                        updateVisibleDefinitions();

                        if (!this.isVertical) {
                            adjustContainerHeight();
                        } else {
                            const contentContainer = containerToUse.closest('#content-container');
                            if (contentContainer) {
                                contentContainer.style.minHeight = '';
                            }
                        }
                    });
                }, 50);
            }

            return result;
        };
    }

    // 折りたたみ要素の設定
    function setupCollapsibleElements() {
        const {collapsibleSelectors, displayNameMap, activeDictionaries} = window.dictionaryContext;
        const dictionariesToProcess = Object.keys(activeDictionaries);

        // イベントハンドラーを早めに登録
        if (!window.dictionaryContext.collapsibleHandlerRegistered) {
            window.dictionaryContext.collapsibleHandlerRegistered = true;

            document.addEventListener('pointerdown', function (e) {
                if (e.target && (
                    e.target.hasAttribute('data-clickable') ||
                    e.target.classList.contains('collapsible-header')
                )) {
                    const wrapper = e.target.closest('.collapsible-wrapper');
                    if (wrapper) {
                        wrapper.classList.toggle('collapsed');
                    }
                }
            }, {passive: true});

            document.addEventListener('mousedown', function (e) {
                if (e.target && e.target.classList.contains('collapsible-header')) {
                    const wrapper = e.target.closest('.collapsible-wrapper');
                    if (wrapper) {
                        wrapper.classList.toggle('collapsed');
                    }
                }
            }, {passive: true, capture: true});
        }

        if (dictionariesToProcess.length === 0) return;

        const allContentElements = [];

        // 折りたたみ対象を探す
        dictionariesToProcess.forEach(dictionaryName => {
            const currentSelectors = collapsibleSelectors[dictionaryName];
            if (!currentSelectors) return;

            const entries = document.querySelectorAll(`li[data-dictionary="${dictionaryName}"]`);
            const container = entries.length > 0 ? entries : [document];

            container.forEach(ctx => {
                currentSelectors.forEach(({selector, displayName}) => {
                    const elements = ctx.querySelectorAll(selector);
                    if (!elements.length) return;

                    elements.forEach(el => {
                        if (el.parentNode && el.parentNode.classList?.contains('collapsible-content')) return;
                        allContentElements.push({
                            element: el,
                            parent: el.parentNode,
                            displayName: displayName
                        });
                    });
                });
            });
        });

        if (allContentElements.length === 0) return;
        const wrappers = [];

        // 折りたたみ用ラッパーを作成
        allContentElements.forEach(item => {
            const {element, parent, displayName} = item;

            const wrapper = document.createElement('div');
            wrapper.className = 'collapsible-wrapper collapsed';

            const header = document.createElement('div');
            header.className = 'collapsible-header';
            header.textContent = displayName;
            header.setAttribute('data-clickable', 'true');

            header.addEventListener('mousedown', function (e) {
                wrapper.classList.toggle('collapsed');
                e.stopPropagation();
            }, {capture: true});

            const content = document.createElement('div');
            content.className = 'collapsible-content';

            wrapper.appendChild(header);
            wrapper.appendChild(content);

            wrappers.push({
                wrapper,
                content,
                element,
                parent
            });
        });

        wrappers.forEach(({wrapper, content, element, parent}) => {
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }

            content.appendChild(element);
            parent.appendChild(wrapper);
        });

        // 既存のヘッダーにもクリック処理を追加
        document.querySelectorAll('.collapsible-header:not([data-clickable])').forEach(header => {
            header.setAttribute('data-clickable', 'true');

            const wrapper = header.closest('.collapsible-wrapper');
            if (wrapper) {
                header.addEventListener('mousedown', function (e) {
                    wrapper.classList.toggle('collapsed');
                    e.stopPropagation();
                }, {capture: true});
            }
        });
    }

    // 画像処理
    function handleImages() {
        const {imageSelectors, activeDictionaries, elements} = window.dictionaryContext;
        const dictionaries = Object.keys(activeDictionaries);

        if (dictionaries.length === 0) return;

        const imageDiv = elements.imageDiv || document.querySelector('#image');
        const imageContainer = elements.imageContainer || document.querySelector('#image-container');

        if (!imageDiv || !imageContainer) return;

        const allImages = [];
        const uniqueImageUrls = new Set();
        let currentImageIndex = 0;
        let imageContainersToHide = [];

        // 既存の画像をチェック
        const existingImages = imageDiv.querySelectorAll('img');
        if (existingImages.length > 0) {
            existingImages.forEach(img => {
                if (!img.src || img.src === window.location.href) return;

                if (uniqueImageUrls.has(img.src)) return;

                uniqueImageUrls.add(img.src);
                const newImg = img.cloneNode(true);
                allImages.push(newImg);
            });
        }

        // 画像コンテナをクリア
        while (imageDiv.firstChild) {
            imageDiv.removeChild(imageDiv.firstChild);
        }

        // 画像を収集する関数
        function collectImagesFromContainer(container, selector) {
            const imageContainers = container.querySelectorAll(selector);
            if (!imageContainers.length) return;

            imageContainers.forEach(container => {
                const imgElements = container.querySelectorAll('img');
                if (!imgElements.length) return;

                imageContainersToHide.push(container);

                imgElements.forEach(img => {
                    if (!img.src || img.src === window.location.href) return;

                    if (uniqueImageUrls.has(img.src)) return;

                    uniqueImageUrls.add(img.src);

                    const newImg = new Image();
                    newImg.src = img.src;
                    newImg.alt = img.alt || '';

                    if (img.title) newImg.title = img.title;
                    if (img.dataset) {
                        Object.keys(img.dataset).forEach(key => {
                            newImg.dataset[key] = img.dataset[key];
                        });
                    }

                    allImages.push(newImg);
                });
            });
        }

        // 各辞書から画像を収集
        for (const dictName of dictionaries) {
            const selector = imageSelectors[dictName] || imageSelectors["default"];

            document.querySelectorAll(`li[data-dictionary="${dictName}"]`)
                .forEach(entry => collectImagesFromContainer(entry, selector));

            if (elements.dictname && elements.dictname.textContent.trim() === dictName) {
                collectImagesFromContainer(document, selector);
            }
        }

        // 元の画像コンテナを削除
        imageContainersToHide.forEach(container => {
            if (container.parentNode) {
                container.parentNode.removeChild(container);
            }
        });

        // 画像がない場合は非表示
        if (allImages.length === 0) {
            imageContainer.style.display = 'none';
            return;
        }

        imageContainer.style.display = '';

        let leftEdge = imageContainer.querySelector('.image-left-edge');
        let rightEdge = imageContainer.querySelector('.image-right-edge');

        if (!leftEdge) {
            leftEdge = document.createElement('div');
            leftEdge.className = 'image-edge-nav image-left-edge';
            imageContainer.appendChild(leftEdge);
        }

        if (!rightEdge) {
            rightEdge = document.createElement('div');
            rightEdge.className = 'image-edge-nav image-right-edge';
            imageContainer.appendChild(rightEdge);
        }

        // 画像切り替えのボタン表示を更新する関数
        function updateEdgeVisibility() {
            if (allImages.length <= 1) {
                leftEdge.style.display = 'none';
                rightEdge.style.display = 'none';
            } else {
                leftEdge.style.display = '';
                rightEdge.style.display = '';
            }
        }

        if (allImages.length > 0) {
            const firstImage = allImages[0];

            firstImage.style.maxWidth = '100%';
            firstImage.style.maxHeight = '210px';
            firstImage.style.objectFit = 'contain';
            firstImage.style.borderRadius = '6px';
            firstImage.style.transition = 'all 0.3s ease';

            imageDiv.appendChild(firstImage);

            updateEdgeVisibility();
        }

        if (allImages.length > 1) {
            function cycleImage(direction) {
                const currentImg = imageDiv.querySelector('img');
                if (currentImg) {
                    imageDiv.removeChild(currentImg);
                }

                // 新しいインデックス計算しよっと
                if (direction === 'next') {
                    currentImageIndex = (currentImageIndex + 1) % allImages.length;
                } else {
                    currentImageIndex = (currentImageIndex - 1 + allImages.length) % allImages.length;
                }

                const newImg = allImages[currentImageIndex];

                newImg.style.maxWidth = '100%';
                newImg.style.maxHeight = '210px';
                newImg.style.objectFit = 'contain';
                newImg.style.borderRadius = '6px';
                newImg.style.transition = 'all 0.3s ease';

                imageDiv.appendChild(newImg);
            }

            // イベントリスナーがダブらないようにクローンして置き換え
            const newLeftEdge = leftEdge.cloneNode(true);
            const newRightEdge = rightEdge.cloneNode(true);

            imageContainer.replaceChild(newLeftEdge, leftEdge);
            imageContainer.replaceChild(newRightEdge, rightEdge);

            // 新しいイベントリスナー追加する
            function addEdgeListeners(element, direction) {
                element.addEventListener('click', function (e) {
                    cycleImage(direction);
                    e.stopPropagation();
                });

                element.addEventListener('touchstart', function (e) {
                    cycleImage(direction);
                    e.stopPropagation();
                    e.preventDefault();
                }, {passive: false});
            }

            addEdgeListeners(newLeftEdge, 'prev');
            addEdgeListeners(newRightEdge, 'next');

            leftEdge = newLeftEdge;
            rightEdge = newRightEdge;
        }

        setupLightbox();

        window.addEventListener('resize', function () {
            requestAnimationFrame(updateEdgeVisibility);
        }, {passive: true});
    }

    function setupLightbox() {
        const lightboxOverlay = document.getElementById('lightbox-overlay');
        const lightboxImage = document.getElementById('lightbox-image');
        const lightboxClose = document.getElementById('lightbox-close');
        const imageDiv = document.getElementById('image');

        if (!lightboxOverlay || !lightboxImage || !imageDiv) return;

        // ズームの段階を設定する
        const zoomLevels = [1, 1.5, 2, 2.5, 3];
        let currentZoomIndex = 0;

        // ライトボックスを閉じる関数
        function closeLightbox() {
            lightboxOverlay.classList.remove('active');
            document.body.style.overflow = 'auto';
            resetZoom();
        }

        // ズームを最初に戻す関数
        function resetZoom() {
            currentZoomIndex = 0;
            lightboxImage.style.transform = 'scale(1)';
            lightboxImage.style.cursor = 'zoom-in';
        }

        // クリックするたびにズームを変える関数
        function cycleZoom() {
            currentZoomIndex = (currentZoomIndex + 1) % zoomLevels.length;
            const zoomLevel = zoomLevels[currentZoomIndex];
            lightboxImage.style.transform = `scale(${zoomLevel})`;

            // 次クリックしたら1倍に戻るかどうかチェック
            const willResetTo1x = currentZoomIndex === zoomLevels.length - 1;
            lightboxImage.style.cursor = willResetTo1x ? 'zoom-out' : 'zoom-in';
        }

        // ライトボックスを開いて画像を表示する関数
        function openLightbox(imgSrc) {
            lightboxImage.src = imgSrc;
            lightboxOverlay.classList.add('active');
            document.body.style.overflow = 'hidden';
            resetZoom();
        }

        // 画像をクリックした時の処理
        imageDiv.addEventListener('click', function (e) {
            const img = e.target.closest('img');
            if (img && img.src) {
                openLightbox(img.src);
            }
        });

        // ライトボックス内の画像をクリックした時の処理
        lightboxImage.addEventListener('click', function (e) {
            e.stopPropagation();
            cycleZoom();
        });

        // 閉じるボタンの処理
        lightboxClose.addEventListener('click', closeLightbox);

        // オーバーレイをクリックした時の処理
        lightboxOverlay.addEventListener('click', function (e) {
            if (e.target === lightboxOverlay) {
                closeLightbox();
            }
        });

        // Escapeキーで閉じられるようにする
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && lightboxOverlay.classList.contains('active')) {
                closeLightbox();
            }
        });
    }

    // グローバルイベントリスナーの設定
    function setupGlobalEventListeners() {
        let resizeRAF = null;
        window.addEventListener('resize', function () {
            if (resizeRAF) {
                cancelAnimationFrame(resizeRAF);
            }

            resizeRAF = requestAnimationFrame(function () {
                // リサイズ時に切替の表示／非表示を処理
                const toggle = document.getElementById('writing-mode-toggle');
                if (toggle) {
                    const toggleContainer = toggle.parentElement.parentElement;
                    toggleContainer.style.display = window.innerWidth <= 600 ? 'none' : '';
                }

                window.dictionaryContext.detectVerticalMode();
            });
        }, {passive: true});

        // 折りたたみヘッダー用のイベントハンドラー
        if (!window.dictionaryContext.collapsibleHandlerRegistered) {
            window.dictionaryContext.collapsibleHandlerRegistered = true;

            // ポインターイベントを使用
            document.addEventListener('pointerdown', function (e) {
                if (e.target && (
                    e.target.hasAttribute('data-clickable') ||
                    e.target.classList.contains('collapsible-header')
                )) {
                    const wrapper = e.target.closest('.collapsible-wrapper');
                    if (wrapper) {
                        wrapper.classList.toggle('collapsed');
                    }
                }
            }, {passive: true});
        }

        // 必要に応じて既存のヘッダーをクリック可能としてマーク
        document.querySelectorAll('.collapsible-header:not([data-clickable])').forEach(header => {
            header.setAttribute('data-clickable', 'true');
        });
    }

    // 読み込みによる辞書コンテンツの待機
    function waitForDictionaryContent() {
        const criticalElements = ['definition', 'content-container', 'dictname'];

        // 重要な要素が準備できているかチェック
        function checkReadiness() {
            return criticalElements.every(id => document.getElementById(id));
        }

        // すべての準備ができていれば初期化
        if (checkReadiness()) {
            initializeDictionaryCard();
            return;
        }

        // MutationObserverを使用
        const observer = new MutationObserver(() => {
            if (checkReadiness()) {
                observer.disconnect();
                initializeDictionaryCard();
            }
        });

        // 追加されたノード用にbodyのみを監視
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // RAFによるフォールバックタイムアウト
        let frameCount = 0;

        function checkAfterFrames() {
            if (checkReadiness() || frameCount > 60) {
                observer.disconnect();
                initializeDictionaryCard();
            } else {
                frameCount++;
                requestAnimationFrame(checkAfterFrames);
            }
        }

        requestAnimationFrame(checkAfterFrames);
    }

    // 適切なタイミングで初期化を開始
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', waitForDictionaryContent);
    } else {
        waitForDictionaryContent();
    }
</script>
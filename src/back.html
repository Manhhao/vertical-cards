<div id="writing-mode-toggle-container">
    <label class="writing-mode-switch">
        <input type="checkbox" id="writing-mode-toggle" checked>
        <span class="slider round"></span>
        <span class="toggle-label">縦書き</span>
    </label>
</div>

<div class="center-wrapper back">
    <div id="container">
        <div id="dictname">{{DictionaryName}}</div>
        <div id="header-container">
            <div class="header-main-content">
                <div id="expression">{{Word}}</div>
                <div id="reading">{{Reading}}</div>
            </div>
            <div class="audio-buttons">
                <div class="word-audio">{{Audio}}</div>
                <div class="sentence-audio">{{SentenceAudio}}</div>
            </div>
        </div>
        <div id="content-container">
            <div id="glossary-container">
                <div id="definition">{{Glossary}}</div>
                <div id="sentence">{{Sentence}}</div>
            </div>
            <div id="image-container">
                <div id="image">{{Picture}}</div>
            </div>
        </div>
    </div>
</div>

<script>
    // Main dictionary context object
    window.dictionaryContext = {
        dictionaryClassNames: {
            "三省堂 全訳読解古語辞典": "skogo",
            "旺文社 全訳古語辞典": "obunsha-kogo",
            "角川新字源 改訂新版": "kadokawa-shinjigen",
            "明鏡国語辞典 第三版": "meikyo",
            "大辞泉 第二版": "daijisen",
            "漢検漢字辞典　第二版": "kankenkj2",
            "新明解国語辞典　第八版": "smk8"
        },

        collapsibleSelectors: {
            "三省堂 全訳読解古語辞典": [
                "div[data-sc絵巻項目]",
                "div[data-sc読解-g]"
            ],
            "旺文社 全訳古語辞典": [
                "div[data-sc用例囲み-g]",
                "div[data-sc発展]"
            ]
        },

        displayNameMap: {
            // 三省堂 全訳読解古語辞典
            "絵巻項目": "絵巻",
            "発展": "発展事項",
            "読解-g": "読解",

            // 旺文社 全訳古語辞典
            "用例囲み-g": "例文・訳"
        },

        imageSelectors: {
            "三省堂 全訳読解古語辞典": "div[data-sc画像-g]",
            "大辞泉 第二版": "div[data-sc-m-image]",

            // Default selectors
            "default": "div[data-sc画像-g], .image-container, .figure, figure, .img-container"
        },

        // Cache elements centrally to avoid repeated DOM queries
        elements: {},
        activeDictionaries: {},
        isVertical: false,
        initialized: false,

        userPreferences: {
            tategakiEnabled: true
        },

        // Modify the detectVerticalMode method
        detectVerticalMode() {
            if (!this.elements.contentContainer) return false;

            const contentContainer = this.elements.contentContainer;

            // Check if mobile view (which should always be horizontal)
            const isMobileView = window.innerWidth <= 600;

            if (isMobileView) {
                // Force horizontal mode on mobile
                this.isVertical = false;
                contentContainer.classList.remove('vertical-mode');
                contentContainer.classList.add('horizontal-mode');
            } else {
                // On desktop, use the user preference
                this.isVertical = this.userPreferences.tategakiEnabled;
                contentContainer.classList.toggle('vertical-mode', this.isVertical);
                contentContainer.classList.toggle('horizontal-mode', !this.isVertical);
            }

            return this.isVertical;
        },

        // Add a method to toggle writing mode
        toggleWritingMode(enabled) {
            if (typeof enabled === 'boolean') {
                this.userPreferences.tategakiEnabled = enabled;
            } else {
                this.userPreferences.tategakiEnabled = !this.userPreferences.tategakiEnabled;
            }

            // Save preference to localStorage
            localStorage.setItem('tategakiEnabled', this.userPreferences.tategakiEnabled);

            // Update the UI
            this.detectVerticalMode();

            // Update toggle if it exists
            const toggle = document.getElementById('writing-mode-toggle');
            if (toggle) {
                toggle.checked = this.userPreferences.tategakiEnabled;
            }

            // Trigger a resize event to refresh any components that depend on writing mode
            window.dispatchEvent(new Event('resize'));
        },


        cacheElements() {
            const selectors = {
                dictionaryEntries: { selector: "li[data-dictionary]", all: true },
                definitionContainer: { selector: "#definition" },
                contentContainer: { selector: "#content-container" },
                dictname: { selector: "#dictname" },
                expression: { selector: "#expression" },
                reading: { selector: "#reading" },
                sentence: { selector: "#sentence" },
                imageDiv: { selector: "#image" },
                imageContainer: { selector: "#image-container" },
                centerWrapperBack: { selector: ".center-wrapper.back" }
            };

            // Cache all elements in a single batch
            for (const [key, { selector, all }] of Object.entries(selectors)) {
                this.elements[key] = all
                    ? document.querySelectorAll(selector)
                    : document.querySelector(selector);
            }
        },

        identifyActiveDictionaries() {
            // Skip if already identified
            if (Object.keys(this.activeDictionaries).length > 0) {
                return Object.keys(this.activeDictionaries);
            }

            this.activeDictionaries = {};
            const entries = this.elements.dictionaryEntries;

            if (entries && entries.length > 0) {
                entries.forEach(entry => {
                    const dictName = entry.getAttribute("data-dictionary");
                    if (dictName) {
                        this.activeDictionaries[dictName] = true;
                    }
                });
            }
            else if (this.elements.dictname && this.elements.dictname.textContent.trim()) {
                this.activeDictionaries[this.elements.dictname.textContent.trim()] = true;
            }

            return Object.keys(this.activeDictionaries);
        },

        applyDictionaryClasses() {
            const { dictionaryClassNames, activeDictionaries } = this;
            const dictionariesToProcess = Object.keys(activeDictionaries);

            if (dictionariesToProcess.length === 0) return;

            const entries = this.elements.dictionaryEntries;
            const definitionContainer = this.elements.definitionContainer;

            requestAnimationFrame(() => {
                // Process individual dictionary entries
                if (entries && entries.length > 0) {
                    entries.forEach(entry => {
                        const dictName = entry.getAttribute("data-dictionary");
                        if (dictName && dictionaryClassNames[dictName]) {
                            entry.classList.add(dictionaryClassNames[dictName]);
                        }
                    });
                }

                // Process the main container (for single dictionary view)
                if (definitionContainer && dictionariesToProcess.length === 1) {
                    const dictName = dictionariesToProcess[0];
                    if (dictionaryClassNames[dictName]) {
                        definitionContainer.classList.add(dictionaryClassNames[dictName]);
                    }
                }
            });
        },

        // Initialise everything at once
        init() {
            if (this.initialized) return;

            // Load saved preference
            const savedPreference = localStorage.getItem('tategakiEnabled');
            if (savedPreference !== null) {
                this.userPreferences.tategakiEnabled = savedPreference === 'true';
            }

            this.cacheElements();
            this.detectVerticalMode();
            this.identifyActiveDictionaries();
            this.applyDictionaryClasses();

            this.initialized = true;
        }
    };

    function initializeDictionaryCard() {
        if (!window.dictionaryContext) return;

        window.dictionaryContext.init();

        // feature operations with their requirements
        const ctx = window.dictionaryContext;
        const features = [
            { fn: handleEmptySentence, requires: ['sentence'] },
            { fn: handleDuplicateContent, requires: ['expression', 'reading', 'sentence'] },
            { fn: setupCyclableDefinitions, requires: ['definitionContainer'] },
            { fn: setupCollapsibleElements, requires: [] },
            { fn: handleImages, requires: [] },
            { fn: hideEmptyImageContainer, requires: ['imageContainer', 'imageDiv'] },
            { fn: setupWritingModeToggle, requires: [] }
        ];

        // First check which elements exist
        const elementsExist = {};
        for (const key in ctx.elements) {
            elementsExist[key] = ctx.elements[key] !== null &&
                !(ctx.elements[key] instanceof NodeList && ctx.elements[key].length === 0);
        }

        // Collect all operations that can run
        const operationsToRun = features
            .filter(feature => feature.requires.every(elem => elementsExist[elem]))
            .map(feature => feature.fn);

        // Execute all operations together in a single animation frame
        if (operationsToRun.length > 0) {
            requestAnimationFrame(() => {
                operationsToRun.forEach(operation => operation());

                // Setup event listeners after all operations are complete
                setupGlobalEventListeners();
            });
        }
    }

    // Add a new feature function for the tategaki toggle
    function setupWritingModeToggle() {
        const { contentContainer } = window.dictionaryContext.elements;
        const toggle = document.getElementById('writing-mode-toggle');

        if (!toggle || !contentContainer) return;

        // Set initial state based on dictionary context
        toggle.checked = window.dictionaryContext.userPreferences.tategakiEnabled;

        // Add change event listener
        toggle.addEventListener('change', function () {
            window.dictionaryContext.toggleWritingMode(this.checked);
        });

        // Initial check for mobile view
        if (window.innerWidth <= 600) {
            toggle.parentElement.parentElement.style.display = 'none';
        }
    }

    // Feature: Hide image container if it's empty
    function hideEmptyImageContainer() {
        const { imageDiv, imageContainer } = window.dictionaryContext.elements;
        if (!imageContainer) return;

        const hasImages = imageDiv && imageDiv.getElementsByTagName('img').length > 0;
        const hasText = imageDiv && imageDiv.innerText.trim() !== '';

        if (!hasImages && !hasText) {
            imageContainer.style.display = 'none';
        }
    }

    // Feature: Hide sentence field if empty
    function handleEmptySentence() {
        const sentenceDiv = window.dictionaryContext.elements.sentence;
        if (sentenceDiv && sentenceDiv.textContent.trim() === "") {
            sentenceDiv.style.display = "none";
        }
    }

    // Feature: Hide reading and sentence if same as term
    function handleDuplicateContent() {
        const { expression, reading, sentence } = window.dictionaryContext.elements;

        if (!expression) return;

        const expressionText = expression.textContent.trim();
        const readingText = reading ? reading.textContent.trim() : null;
        const sentenceText = sentence ? sentence.textContent.trim() : null;

        requestAnimationFrame(() => {
            if (reading && expressionText === readingText) {
                reading.style.display = "none";
            }

            if (sentence && expressionText === sentenceText) {
                sentence.style.display = "none";
            }
        });
    }

    // Update the setupCyclableDefinitions function to prevent the flash
    // Update to setupCyclableDefinitions function to use dictionary names
    function setupCyclableDefinitions() {
        const definitionContainer = window.dictionaryContext.elements.definitionContainer;
        if (!definitionContainer) return;

        const definitionItems = Array.from(definitionContainer.querySelectorAll("li[data-dictionary]"));
        if (definitionItems.length <= 1) return; // No need for cycling

        // Hide all definition items initially to prevent flash
        definitionItems.forEach(item => item.style.display = "none");

        // Only show the first one by default until proper calculation
        if (definitionItems[0]) {
            definitionItems[0].style.display = "";
        }

        // Create all UI elements in fragment
        const fragment = document.createDocumentFragment();
        const counterElement = document.createElement("div");
        const leftEdge = document.createElement("div");
        const rightEdge = document.createElement("div");

        counterElement.className = "definition-counter";
        leftEdge.className = "definition-left-edge";
        rightEdge.className = "definition-right-edge";

        fragment.appendChild(counterElement);
        fragment.appendChild(leftEdge);
        fragment.appendChild(rightEdge);

        const containerToUse = window.dictionaryContext.elements.contentContainer || definitionContainer;
        containerToUse.style.position = "relative";

        let currentStartIndex = 0;
        let visibleCount = 1;
        const totalDefinitions = definitionItems.length;

        // Map of dictionary indices to their names for display
        const dictionaryNames = definitionItems.map(item => {
            const dictName = item.getAttribute("data-dictionary");
            return dictName || `辞書 ${definitionItems.indexOf(item) + 1}`; // Use generic name if none provided
        });

        let lastMeasuredWidth = 0;
        let lastMeasuredHeight = 0;
        let hasCalculatedInitialLayout = false;

        // Calculate visible definitions
        function calculateVisibleCount() {
            // Force a fresh check of vertical mode before calculating
            window.dictionaryContext.detectVerticalMode();
            const isVertical = window.dictionaryContext.isVertical;

            const containerRect = containerToUse.getBoundingClientRect();

            // Cache container dimensions to detect real size changes
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;

            // If dimensions haven't changed, skip recalculation
            if (containerWidth === lastMeasuredWidth &&
                containerHeight === lastMeasuredHeight &&
                hasCalculatedInitialLayout) {
                return visibleCount;
            }

            lastMeasuredWidth = containerWidth;
            lastMeasuredHeight = containerHeight;

            // For measurement only: temporarily show all definitions but with visibility:hidden
            // This prevents the flash while still allowing accurate measurements
            definitionItems.forEach(item => {
                item.style.display = "";
                item.style.visibility = "hidden";
            });

            // The key dimension depends on writing mode
            const containerSize = isVertical ? containerWidth : containerHeight;

            // Use a more generous space allocation for horizontal mode
            const safetyMargin = isVertical ? 0.9 : 0.9; // More space in horizontal mode
            const usableSpace = containerSize * safetyMargin;

            let totalUsedSpace = 0;
            let count = 0;

            // For horizontal mode, we need to be more precise with our measurements
            if (!isVertical) {
                // Force a layout calculation to ensure accurate measurements
                containerToUse.offsetHeight; // This triggers a reflow

                // Wait briefly for any pending layout adjustments
                const tempItems = [...definitionItems];

                // Sort items by height to prioritize showing more items if they're shorter
                if (tempItems.length > 1) {
                    tempItems.sort((a, b) => {
                        const aRect = a.getBoundingClientRect();
                        const bRect = b.getBoundingClientRect();
                        return aRect.height - bRect.height;
                    });
                }

                // Measure items one by one and see how many fit
                for (const item of tempItems) {
                    const itemRect = item.getBoundingClientRect();
                    const style = window.getComputedStyle(item);

                    // Height + margins in horizontal mode
                    const itemSize = itemRect.height +
                        parseFloat(style.marginTop) +
                        parseFloat(style.marginBottom);

                    // Include additional buffer for horizontal mode
                    const itemWithBuffer = itemSize * 1.05; // 5% buffer for safety

                    // Stop if adding this item would exceed container
                    if (totalUsedSpace + itemWithBuffer > usableSpace) break;

                    totalUsedSpace += itemWithBuffer;
                    count++;
                }
            } else {
                // Original vertical mode calculation
                for (const item of definitionItems) {
                    const itemRect = item.getBoundingClientRect();
                    const style = window.getComputedStyle(item);

                    // Width + margins in vertical mode
                    const itemSize = itemRect.width +
                        parseFloat(style.marginLeft) +
                        parseFloat(style.marginRight);

                    // Stop if adding this item would exceed container
                    if (totalUsedSpace + itemSize > usableSpace) break;

                    totalUsedSpace += itemSize;
                    count++;
                }
            }

            // Reset visibility
            definitionItems.forEach(item => {
                item.style.visibility = "";
                item.style.display = "none"; // Hide all again
            });

            hasCalculatedInitialLayout = true;

            // Always show at least one definition
            return Math.max(1, count);
        }

        // Update which definitions are visible
        function updateVisibleDefinitions() {
            // Make sure all are hidden first
            definitionItems.forEach(item => item.style.display = "none");

            // Show correct subset of definitions
            const actualVisibleCount = Math.min(visibleCount, totalDefinitions - currentStartIndex);

            for (let i = 0; i < actualVisibleCount; i++) {
                definitionItems[currentStartIndex + i].style.display = "";
            }

            const endIndex = currentStartIndex + actualVisibleCount - 1;

            if (visibleCount >= totalDefinitions) {
                counterElement.textContent = "全てを表示";
            } else if (actualVisibleCount === 1) {
                // Show current dictionary name and total
                counterElement.textContent = `(${currentStartIndex + 1}/${totalDefinitions})`;
            } else {
                // Show range of dictionary names
                counterElement.textContent = ` (${currentStartIndex + 1}-${endIndex + 1}/${totalDefinitions})`;
            }

            // Show/hide navigation elements
            const showNavigation = visibleCount < totalDefinitions;
            leftEdge.style.display = rightEdge.style.display = showNavigation ? "" : "none";
        }

        // Cycle to the next/previous set of definitions
        function cycleDefinitions(direction) {
            if (visibleCount >= totalDefinitions) return;

            const totalGroups = Math.ceil(totalDefinitions / visibleCount);
            const currentGroupIndex = Math.floor(currentStartIndex / visibleCount);

            if (direction === "next") {
                const nextGroupIndex = (currentGroupIndex + 1) % totalGroups;
                currentStartIndex = nextGroupIndex * visibleCount;
            } else {
                const prevGroupIndex = (currentGroupIndex - 1 + totalGroups) % totalGroups;
                currentStartIndex = prevGroupIndex * visibleCount;
            }

            updateVisibleDefinitions();
        }

        leftEdge.addEventListener("click", () => cycleDefinitions("prev"));
        rightEdge.addEventListener("click", () => cycleDefinitions("next"));

        // Add keyboard navigation
        document.addEventListener("keydown", (event) => {
            if (event.key === "ArrowLeft" || event.keyCode === 37) {
                cycleDefinitions("prev");
            } else if (event.key === "ArrowRight" || event.keyCode === 39) {
                cycleDefinitions("next");
            }
        }, { passive: true });

        // Efficient debounce function
        function debounce(func, wait) {
            let timeout;
            return function () {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(), wait);
            };
        }

        // Initialize the UI elements and perform initial calculations
        containerToUse.appendChild(fragment);

        // Initial counter state - now shows the dictionary name
        if (dictionaryNames.length > 0) {
            counterElement.textContent = `(1/${totalDefinitions})`;
        }

        // Show navigation if needed
        const showNavigation = totalDefinitions > 1;
        leftEdge.style.display = rightEdge.style.display = showNavigation ? "" : "none";

        // Use requestIdleCallback for calculation if available, or requestAnimationFrame if not
        const scheduleInitialCalculation = window.requestIdleCallback || requestAnimationFrame;

        scheduleInitialCalculation(() => {
            visibleCount = calculateVisibleCount();
            updateVisibleDefinitions();
        });

        const debouncedResize = debounce(() => {
            visibleCount = calculateVisibleCount();
            updateVisibleDefinitions();
        }, 250);

        window.addEventListener('resize', debouncedResize, { passive: true });

        // Handle writing mode changes
        const originalDetectVerticalMode = window.dictionaryContext.detectVerticalMode;
        window.dictionaryContext.detectVerticalMode = function () {
            const wasVertical = this.isVertical;
            const result = originalDetectVerticalMode.call(this);

            if (wasVertical !== this.isVertical) {
                // Reset cached dimensions to force recalculation
                lastMeasuredWidth = lastMeasuredHeight = 0;

                // Recalculate on next frame
                requestAnimationFrame(() => {
                    visibleCount = calculateVisibleCount();
                    updateVisibleDefinitions();
                });
            }

            return result;
        };
    }

    function setupCollapsibleElements() {
        const { collapsibleSelectors, displayNameMap, activeDictionaries } = window.dictionaryContext;
        const dictionariesToProcess = Object.keys(activeDictionaries);

        if (dictionariesToProcess.length === 0) return;

        const allContentElements = [];

        // Read phase - identify elements that need to be collapsible
        dictionariesToProcess.forEach(dictionaryName => {
            const currentSelectors = collapsibleSelectors[dictionaryName];
            if (!currentSelectors) return;

            const entries = document.querySelectorAll(`li[data-dictionary="${dictionaryName}"]`);
            const container = entries.length > 0 ? entries : [document];

            container.forEach(ctx => {
                currentSelectors.forEach(selector => {
                    const elements = ctx.querySelectorAll(selector);
                    if (!elements.length) return;

                    const attrMatch = selector.match(/data-sc([^=\]]*)/);
                    const rawAttrName = attrMatch ? attrMatch[1] : selector.split('[')[1]?.split(']')[0];
                    if (!rawAttrName) return;

                    const displayName = displayNameMap[rawAttrName] || rawAttrName;

                    elements.forEach(el => {
                        // Skip if already wrapped
                        if (el.parentNode && el.parentNode.classList?.contains('collapsible-content')) return;

                        allContentElements.push({
                            element: el,
                            parent: el.parentNode,
                            displayName: displayName
                        });
                    });
                });
            });
        });

        // Skip if nothing to process
        if (allContentElements.length === 0) return;

        // Write phase - create wrappers and attach event listeners
        requestAnimationFrame(() => {
            allContentElements.forEach(item => {
                const { element, parent, displayName } = item;

                const wrapper = document.createElement('div');
                wrapper.className = 'collapsible-wrapper collapsed';

                const header = document.createElement('div');
                header.className = 'collapsible-header';
                header.textContent = displayName;

                const content = document.createElement('div');
                content.className = 'collapsible-content';

                // Insert into DOM
                parent.insertBefore(wrapper, element);
                wrapper.appendChild(header);
                wrapper.appendChild(content);
                content.appendChild(element);

                // Add click event listener to header only
                header.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    wrapper.classList.toggle('collapsed');
                }, { passive: false });
            });
        });
    }
    // Feature: Show only the first image in dictionary entries
    function handleImages() {
        const { imageSelectors, activeDictionaries } = window.dictionaryContext;
        const dictionaries = Object.keys(activeDictionaries);

        if (dictionaries.length === 0) return;

        // Batch operation for hiding images
        const imagesToHide = [];

        function collectExtraImages(container, selector) {
            const images = container.querySelectorAll(selector);
            if (images.length > 1) {
                for (let i = 1; i < images.length; i++) {
                    imagesToHide.push(images[i]);
                }
            }
        }

        // Handle <li> dictionary entries
        for (const dictName of dictionaries) {
            const selector = imageSelectors[dictName] || imageSelectors["default"];
            document.querySelectorAll(`li[data-dictionary="${dictName}"]`)
                .forEach(entry => collectExtraImages(entry, selector));
        }

        // Handle single dictionary entry layout
        const dictnameEl = window.dictionaryContext.elements.dictname;
        if (dictnameEl) {
            const singleDict = dictnameEl.textContent.trim();
            if (activeDictionaries[singleDict]) {
                const selector = imageSelectors[singleDict] || imageSelectors["default"];
                collectExtraImages(document, selector);
            }
        }

        // Apply all changes at once
        if (imagesToHide.length > 0) {
            requestAnimationFrame(() => {
                imagesToHide.forEach(img => {
                    img.style.display = "none";
                });
            });
        }
    }

    // Set up global event listeners
    function setupGlobalEventListeners() {
        // Optimize resize handler with requestAnimationFrame
        let resizeRAF = null;
        window.addEventListener('resize', function () {
            if (resizeRAF) {
                cancelAnimationFrame(resizeRAF);
            }

            resizeRAF = requestAnimationFrame(function () {
                // Handle toggle visibility on resize
                const toggle = document.getElementById('writing-mode-toggle');
                if (toggle) {
                    const toggleContainer = toggle.parentElement.parentElement;
                    toggleContainer.style.display = window.innerWidth <= 600 ? 'none' : '';
                }

                window.dictionaryContext.detectVerticalMode();
                adjustCyclablePositions();
            });
        });

        // Add click handlers for collapsible headers - done once globally with event delegation
        document.addEventListener('click', function (e) {
            if (e.target && e.target.classList.contains('collapsible-header')) {
                const wrapper = e.target.closest('.collapsible-wrapper');
                if (wrapper) {
                    wrapper.classList.toggle('collapsed');
                }
            }
        });
    }

    // Use MutationObserver to wait for dictionary content to be fully loaded
    function waitForDictionaryContent() {
        const criticalElements = ['definition', 'content-container', 'dictname'];

        // Check if all critical elements are ready
        function checkReadiness() {
            return criticalElements.every(id => document.getElementById(id));
        }

        // Init if everything is already ready
        if (checkReadiness()) {
            initializeDictionaryCard();
            return;
        }

        // Otherwise, set up a MutationObserver to wait
        const observer = new MutationObserver(() => {
            if (checkReadiness()) {
                observer.disconnect();
                initializeDictionaryCard();
            }
        });

        // Start observing the document for added nodes
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Fallback: initialize after a timeout even if not all elements are ready
        // Using requestAnimationFrame for more precise timing
        let frameCount = 0;
        function checkAfterFrames() {
            if (checkReadiness() || frameCount > 60) { // 60 frames ≈ 1 second at 60fps
                observer.disconnect();
                if (!checkReadiness()) {
                    console.warn('Some dictionary elements not found, initializing anyway');
                }
                initializeDictionaryCard();
            } else {
                frameCount++;
                requestAnimationFrame(checkAfterFrames);
            }
        }

        requestAnimationFrame(checkAfterFrames);
    }

    // Start the initialization process
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', waitForDictionaryContent);
    } else {
        waitForDictionaryContent();
    }
</script>